
## 进程间通信IPC

方式有：
- 信号（ signal），用来表示事件的发生。
- 管道（亦即 shell 用户所熟悉的“ |”操作符）和 FIFO，用于在进程间传递数据。
- 套接字，供同一台主机或是联网的不同主机上所运行的进程之间传递数据。
- 文件锁定，为防止其他进程读取或更新文件内容，允许某进程对文件的部分区域加以锁定。
- 消息队列，用于在进程间交换消息（数据包）。
- 信号量（ semaphore），用来同步进程动作。
- 共享内存，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容时，其他所有进程会立即了解到这一变化。

贴士：就本质而言， FIFO和 UNIX 套接字功能相同，允许同一系统上并无关联的进程彼此交换数据。二者之所以并存于现代 UNIX 系统之中，是由于 FIFO 来自 System V，而套接字则源于 BSD  

### 内存映射

调用系统函数 mmap()的进程，会在其虚拟地址空间中创建一个新的内存映射。  

映射分为两类：
- 文件映射：将文件的部分区域映射入调用进程的虚拟内存。映射一旦完成，对文件映射内容的访问则转化为对相应内存区域的字节操作。映射页面会按需自动从文件中加载
- 无文件与之相对应的匿名映射，其映射页面的内容会被初始化为 0。

由某一进程所映射的内存可以与其他进程的映射共享。达成共享的方式有二：其一是两个进程都针对某一文件的相同部分加以映射，其二是由 fork()创建的子进程自父进程处继承映射。当两个或多个进程共享的页面相同时，进程之一对页面内容的改动是否为其他进程所见呢？这取决于创建映射时所传入的标志参数。若传入标志为私有，则某进程对映射内容的修改对于其他进程是不可见的，而且这些改动也不会真地落实到文件上；若传入标志为共享，对映射内容的修改就会为其他进程所见，并且这些修改也会造成对文件的改动。内存映射用途很多，其中包括：以可执行文件的相应段来初始化进程的文本段、内存（内容填充为 0）分配、文件 I/O（即映射内存 I/O）以及进程间通信（通过共享映射）。  

## /proc文件系统

/proc 文件系统装配与 /proc 目录下。  

/proc 文件系统是一种虚拟文件系统，以文件系统目录和文件形式，提供一个指向内核数据结构的接口。  

这为查看和改变各种系统属性开启了方便之门。此外，还能通过一组以/proc/PID 形式命名的目录（ PID 即进程 ID）查看系统中运行各进程的相关信息。
通常， /proc 目录下的文件内容都采取人类可读的文本形式， shell 脚本也能对其进行解析。  

程序可以打开、读取和写入/proc 目录下的既定文件。大多数情况下，只有特权级进程才能修改/proc 目录下的文件内容。  


## 操作系统模型

系统模型：计算机用操作系统来管理所有的资源，并将不同的设备和不同的程序连接起来。有了操作系统后，多用户的连接，各种数据读写操作才能得到有效的控制和管理。  

贴士：操作系统 也是程序，与普通程序一样，运行在内存中，同时它也是一个特殊的程序，能够把普通程序与其他程序、设备连接起来。

有了系统模型，计算机的内存空间就会被划分为两部分：
- 用户空间：容纳应用程序的内存空间，所有的程序都必须在内存空间中才能运行
- 系统空间：容纳操作系统的内存空间，也可以称为内核

必须通过内核，程序要访问设备（键盘、磁盘等），因为只有内核才能直接管理设备。

## 系统资源

内核用来管理资源，那么操作系统有哪些资源：
- 1.处理器（Processor）：执行指令（程序）的硬件设备，有1到多个，内核可以安排一个程序何时执行，何时暂停，何时恢复，何时终止
- 2.输入输出（I/O):终端、程序、硬盘等地方的输入/输出数据都会经过内核，这样的好处是：
  - 数据流不会流错地方
  - 开发者不需要考虑不同的设备差异
  - 数据信息不会被未授权的程序非法访问
- 3.进程管理（Process Management）：进程代表一个程序的运行，进程内包含了该程序的资源：内存、打开的文件、运行时所需系统资源，内核可以新建进程、终止进程、调度进程
- 4.内存（Memory）：只有加载到内存的程序才可以运行。内核在需要的时候回给程序分配内存、回收内存，并能保证内存不被其他进程非法访问
- 5.设备（Device）：内核能够屏蔽光驱、鼠标、扫描仪等外设的差异，如：一个程序想要从计算机中拷贝照片到移动硬盘中，只需要向内核提出操作该资源的请求即可
- 6.计时器（Timers）：程序的工作与实践有关，有时需要定时被处罚，有时需要等待，有时需要知道运行消耗实践，内核可以通过系统调用向程序提供计时器服务
- 7.进程间通信（Interprocess Communication）：各个进程之间需要通信，内核为通信提供一系列方式
- 8.网络（Networking）：不同主机的进程，即使使用不同的操作系统也可以互相通信，内核会提供通信的标准服务

Unix系统编程中重要的三个方面：
- 通信：某个用户或者进程如何与其他用户或进程交换信息
- 协作：程序如何协调多个进程使他们能够没有冲突的访问共享资源
- 网络：不同计算机之间通过网络连接到一起，计算机中的程序如何使用网络访问其他计算机的资源


## 信号

Ctrl+C可以终止一个正在运行的程序，这个中断是由一个内核机制产生，该机制即信号。  

Ctrl+C产生的信号工作机制：
- 1 驱动程序收到Ctrl+C产生的字符（可以是Ctrl-C，也可以是stty，tcsetattr）
- 2 匹配VINTR和ISIG的字符被开启
- 3 驱动程序调用信号系统
- 4 信号系统发送SIGINT到进程
- 5 进程收到SIGINT
- 6 进程消亡

信号：由单个词组成的消息，比如中断信号通常是编码2。  

信号来自内核，但是信号的请求来自三个地方：
- 用户：比如Ctrl-C，或者一些终端驱动产生
- 内核：进程执行出错，内核会向进程发送信号，如浮点数溢出等
- 进程：进程可以通过kill给另一个进程发送信号（其实信号是进程间通信的方式之一）

信号的分类：
- 同步信号（synchronous signals）：由进程的某个操作产生的信号，如：被零除
- 异步信号（asynchronous signals）：由进程外的事件引起的信号，如：用户输入Ctrl-C

liunx中，信号的定义位于`/usr/inlude/signal.h`文件中，如下所示：
```
# define SIGHUP     1
# define SIGINT     2
# define SIGQUIT    3
...
```
SIGINT即是中断信号

## 信号处理模型：进程如何处理信号

比如进程接收到信号SIGINT（终止信号），并不是一定会消亡，进程能够通过系统调用signal告诉内核，该如何处理信号，进程有三种选择：
- 选择1：默认选择（通常会消亡），调用函数为：`signal(SIGINT, SIG_DFL)`
- 选择2：忽略信号，程序调用方法`signal(SIGINT, SIG_IGN)`告诉内核忽略掉SIGINT信号
- 选择3：调用一个函数，该函数被称为信号处理函数，`signal(signum, functionname)`

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

int main() {

    void handler(int);          // 声明信号处理函数
    signal(SIGINT, handler);    // 装载信号处理函数

    int i;
    for(i = 0; i < 100; i++) {
        printf("i==%d\n", i);
        sleep(1);
    }
}

void handler(int signum) {
    printf("handle.... \n");
}
```

上述函数在运行时，使用Ctrl-C发送信号后，程序将会打印：`handle.....`，示例中并没有对handler函数进行显示调用。 

同理，如果signal函数这样书写，则Ctrl-C对程序不会产生影响：
```c
signal(SIGINT, SIG_IGN);
```

## 多信号处理模型

如果只有一个信号要处理，上述原始的信号处理模型足以应付。如果有多个信号到达呢？信号的响应如果是终止或者忽略，则结果很清晰，但是响应式调用一个函数，那么结果会产生影响：

问题一 捕鼠器问题：老鼠被捕获后，捕鼠器就失效了，信号处理函数也是，所以每次捕获信号后，都要重新设置。  
```c
// 为解决捕鼠器问题，信号处理函数可能如下：
void handler(int s) {
    signal(SIGINT, handler);        // 重设处理函数，造成信号捕获后，要先重设处理函数，再执行业务逻辑
    ...                             // 业务处理逻辑    
}

```

就算信号重设的再快，也是耗时的，这时候有可能出现：弹簧被处罚和设置完成之间，老鼠溜走了。这个间隙让信号处理不可靠，称为：不可靠信号。  

问题二：进程在处理一个信号时候，其他到达信号就会阻塞，如果多个信号同时到达，该如何处理：  

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>

int main(int ac, char *av[]) {

    void intHandler(int);
    void quitHandler(int);

    char input[100];
    int nchars;

    signal(SIGINT, intHandler);
    signal(SIGQUIT, quitHandler);

    do {
        printf("\nType a msg\n");
        nchars = read(0, input, 100 - 1);
        if(nchars == -1) {
            perror("read returned an error");
        } else {
            input[nchars] = '\0';
            printf("You typed: %s", input);
        }
    } while( strncmp(input, "quit", 4) != 0);
   
}

void intHandler(int s) {
    printf("Received signal %d .. waiting\n", s);
    sleep(2);
    printf(" Leaving intHandler \n");
}

void quitHandler(int s) {
    printf("Received signal %d .. waiting\n", s);
    sleep(3);
    printf(" Leaving quitHandler \n");
}
```

这时，可以如下操作：
- 同时发出多次 Ctrl-C：会阻塞后续的相同信号
- 发出Ctrl-C后，瞬间发出Ctrl-\：程序会先进入intHandler，再进入quitHandler，再回到intHandler，最后回到主循环。
- 输入文字后，再按Ctrl-C，在输入文字：程序在执行时，收到中断信号，Unix经典模式中是返回并设置EINTR为-1

旧时代信号系统仍然被支持，但是也有新的信号系统，比如POSIX模型中的signaction替代了signal：
```c
signaction(signalnumber, signalaction, prevaction);       # 新操作设置成功返回0，否则返回-1
```
参数一：指定要处理的消息  
参数二：指向如何响应信号的结构体  
参数三：如果不是null，则指向被替换的处理设置的结构体

示例：
```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>

int main(int ac, char *av[]) {

    struct sigaction newHandler;
    sigset_t        blocked;
    void            intHandler();
    char            x[100];

    newHandler.sa_handler = intHandler;
    newHandler.sa_flags = SA_RESETHAND;

    sigemptyset(&blocked);
    sigaddset(&blocked, SIGQUIT);
    newHandler.sa_mask = blocked;

    if(sigaction(SIGINT, &newHandler, NULL) == -1){
        perror("sigaction");
    } else {
        while(1){
            fgets(x, 100, stdin);
            printf("input: %s", x);
        }
    }
   
}

void intHandler(int s) {
    printf("Called with signal %d \n", s);
    sleep(s);
    printf("Done handing signal %d\n", s);
}
```

如果以很快的速度连续按Ctrl-C和Ctrl-\，退出信号将被阻塞直到中断信号处理完毕。  
如果连续按两下Ctrl-C，进程就被第二个信号杀死。  
如果想要捕获所有的Ctrl-C，将SA-RESETHAND掩码从sa_flags中去掉。  

## 临界区

如果某段代码在修改数据时被打断，就会造成数据的不完整，则称这段代码临界区。  

程序在处理信号时，必须决定哪一段代码是临界区，然后设法保护这段代码。但是很多临界区不一定就在信号处理函数中，而是在常规程序流中，保护临界区的简单办法是阻塞或忽略那些处理函数将要使用或者修改特定数据的信号。  

可以在信号处理者一级或者进程一级阻塞信号。  

#### 在信号处理者一级阻塞信号

为了在处理一个信号的时候阻塞另一个信号，要设置struct sigaction结构中的sa_mask成员位，它在设置处理函数时被传递给sigaction。 sa_mask是sigset_t类型，定义了一个信号集。

#### 进程的信号阻塞

进程一直都有一些信号被阻塞，这些信号集称为信号挡板（signal mask），通过sigprocmask可以修改这个被阻塞的信号集，sigprocmask本身也是一个原子操作：
```c
int res = sigprocmask(int how, const sigset_t * sigs, sigset_t * prev);     // 返回值为0则成功，-1为失败
```
参数：
- how：如何修改信号挡板
- sigs：指向使用的信号列表的指针
- prev：指向之前的信号挡板列表的指针或者为null

当how值分别为SIG_BLOCK,SIG_UNBLOCK,SIG_SET时候，* sigs所指定的信号将被添加、删除、替换。如果 prev不是null，那么之前的信号挡板设置将被赋值到*prev中。  

#### sigsetops构建信号机

一个sigset_t是一个抽象的信号集，可以通过一些函数来添加或删除信号，基本函数如下：
```c
sigemptyset(sigset_t * setp);           // 清除由setp指向的列表中的所有信号
sigfillset(sigset_t * setp);            // 添加所有的信号到setp指向的类表
sigaddset(sigset_t *setp, int signum);  // 添加signum到setp指向的列表
sigdelset(sigset_t *setp, int signum);  // 从setp指向的列表中删除signum所标识的信号
```

## kill 从另一个进程发送信号

进程可以通过kill系统调用向另一个进程发送信号：
```c
int kill(pid_t pid, int sig);
```
## 未定义信号

Unix有两个信号SIGUSR1和SIGUSR2，没有预定义任务，可以被用户程序使用。  

## 程序的运行

一个程序是存储在文件中的机器指令序列，由编译器将源码编译成二进制文件后，可以运行。运行该程序意味着将这个机器指令序列载入内存然后让处理器逐条执行。  

在Unix中，一个可执行程序是一个机器指令及其数据序列，一个进程是程序运行时的内存空间和设置。  

进程位于用户空间，通过ps(process status)命令查看，每个进程都有一个可以唯一标识的数字，称为PID（进程ID）。
```
ps      #  列出进程
ps -a   #  列出所有进程，包括其他终端、其他用户运行的程序，但并不包括shell进程，-l可以打印更多细节
```

S：代表进程状态，值为R表示进程正在运行，S表示处于睡眠状态
UID：表示该进程所对应的用户
PRI和NI：分别是进程的由县级和niceness级，内核根据这些值来决定什么时候运行进程，一个进程可以增加niceness级别，（类似排队时被安排到更前位置）。
SZ：进程占据内存的大小。
WCHAN：进程睡眠原因，其值read_c或do_sel代表内核地址   


内存可以看做是一个容纳内核和进程的空间，很多系统把内存看做由页面构成的数组，将继承分割到不同的页面，物理上，这些页面存储在固体的芯片中。  
内存实际上是一个字节序列，或者说是一个很大的数组，如果机器有64M内存，那么这个数组大约有6700万个内存位置，其中一些用来存放组成内核的机器指令和数据。   

建立一个进程类似于建立一个磁盘文件，内核要找到一些用来存放程序指令和数据的空闲页，还要额外建立数据结构来存储响应的内存分配情况、进程属性等。  

一个程序运行另外一个程序调用：execvp
建立新的进程：fork