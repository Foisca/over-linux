## 进程

进程是正在执行的程序实例。执行程序时，内核会将程序代码载入虚拟内存，为程序变量分配空间，建立内核记账（ bookkeeping）数据结构，以记录与进程有关的各种信息（比如，进程 ID、用户 ID、组 ID 以及终止状态等）。  

在内核看来，进程是一个个实体，内核必须在它们之间共享各种计算机资源。内核一开始会为进程分配一定数量的资源（如受限的内存），并在进程的生命周期内，
统筹该进程和整个系统对资源的需求，对这一分配进行调整。程序终止时，内核会释放所有此类资源，供其他进程重新使用。其他资源（如 CPU、网络带宽等）都属于可再生资源，但必须在所有进程间平等共享。  


逻辑上将一个进程划分为以下几部分（即在内存找那个的布局）：
- 文本：程序的指令。
- 数据：程序使用的静态变量。
- 堆：程序可从该区域动态分配额外内存。
- 栈：随函数调用、返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间。  

#### 创建进程

进程可使用系统调用 fork()来创建一个新进程。调用 fork()的进程被称为父进程，新创建的进程则被称为子进程。  

内核通过对父进程的复制来创建子进程。子进程从父进程处继承数据段、栈段以及堆段的副本后，可以修改这些内容，不会影响父进程的“原版”内容。 （在内存中被标记为只读的程序文本段则由父、子进程共享。 ）  

#### 进程执行程序

子进程被创建后：
- 要么去执行与父进程共享代码段中的另一组不同函数
- 要么使用系统调用 execve()去加载并执行一个全新程序。 execve()会销毁现有的文本段、数据段、栈段及堆段，并根据新程序的代码，创建新段来替换它们。  

贴士：实际上不存在exec()库函数，而是以此名称为基础，C语言提供了多个相关函数。   

#### 进程ID和父进程ID 

每一进程都有一个唯一的整数型进程标识符（ PID）。此外，每一进程还具有一个父进程标识符（ PPID）属性，用以标识请求内核创建自己的进程。  

#### 进程终止和终止状态

可使用以下两种方式之一来终止一个进程：
- 方式一：进程可使用_exit()系统调用（或相关的exit()库函数），请求退出，此时进程会指明自己的终止状态
- 方式二：向进程传递信号，将其“杀死”，此时根据信号类型设置进程终止状态

贴士：
- 退出的进程都会生成“终止状态”，一个非负小整数，可供父进程的wait()系统调用检测。  
- 有时会将传递进_exit()的参数称为进程的“退出状态”，以示与终止状态有所不同，后者要么指传递给_exit()的参数值，要么表示“杀死”进程的信号。

根据惯例，终止状态为 0 表示进程“功成身退”，非 0 则表示有错误发生。大多数 shell 会将前一执行程序的终止状态保存于 shell 变量$?中。  

#### 进程的用户和组标识符（凭证）

每个进程都有一组与之相关的用户 ID (UID)和组 ID (GID)，如下所示：
- 真实用户 ID 和组 ID：用来标识进程所属的用户和组。新进程从其父进程处继承这些 ID。登录 shell 则会从系统密码文件的相应字段中获取其真实用户 ID 和组 ID。
- 有效用户 ID 和组 ID：进程在访问受保护资源（比如，文件和进程间通信对象）时，会使用这两个 ID（并结合下述的补充组 ID）来确定访问权限。一般情况下，
进程的有效 ID 与相应的真实 ID 值相同。正如即将讨论的那样，改变进程的有效ID 实为一种机制，可使进程具有其他用户或组的权限。
- 补充组 ID：用来标识进程所属的额外组。新进程从其父进程处继承补充组 ID。登录shell 则从系统组文件中获取其补充组 ID。

#### 特权进程

特权进程是指有效用户 ID 为 0（超级用户）的进程。通常由内核所施加的权限限制对此类进程无效。   

“无特权”（或非特权）进程是指由其他用户运行的进程。此类进程的有效用户 ID 为非 0 值，且必须遵守由内核所强加的权限规则。  

由特权进程创建的进程，也可以是特权进程。例如，一个由 root（超级用户）发起的登录 shell。成为特权进程的另一方法是利用 set-user-ID 机制，该机制允许某进程的有效用户ID 等同于该进程所执行程序文件的用户 ID。  

#### 能力（Capabilities）

Linux 把传统上赋予超级用户的权限划分为一组相互独立的单元（称之为“能力”）。  

每次特权操作都与特定的能力相关，仅当进程具有特定能力时，才能执行相应操作。传统意义上的超级用户进程（有效用户 ID 为 0）则相应开启了所有能力。
赋予某进程部分能力，使得其既能够执行某些特权级操作，又防止其执行其他特权级操作。能力的命名以 CAP_为前缀，例如， CAP_KILL。

#### init进程

系统引导时，内核会创建一个名为 init 的特殊进程，即“所有进程之父”，该进程的相应程序文件为/sbin/init。系统的所有进程不是由 init（使用 frok()）“亲自”创建，就是由其后代进程创建。 init 进程的进程号总为 1，且总是以超级用户权限运行。谁（哪怕是超级用户）都不能“杀死” init 进程，只有关闭系统才能终止该进程。 init 的主要任务是创建并监控系统运行所需的一系列进程。   

#### 守护进程


守护进程指的是具有特殊用途的进程，系统创建和处理此类进程的方式与其他进程相同，但以下特征是其所独有的：
- “长生不老”。守护进程通常在系统引导时启动，直至系统关闭前，会一直“健在”。
- 守护进程在后台运行，且无控制终端供其读取或写入数据。

守护进程中的例子有 syslogd（在系统日志中记录消息）和 httpd（利用 HTTP 分发 Web 页面）

#### 环境列表

每个进程都有一份环境列表，即在进程用户空间内存中维护的一组环境变量。这份列表的每一元素都由一个名称及其相关值组成。由 fork()创建的新进程，会继承父进程的环境副本。这也为父子进程间通信提供了一种机制。当进程调用 exec()替换当前正在运行的程序时，新程序要么继承老程序的环境，要么在 exec()调用的参数中指定新环境并加以接收。  

在绝大多数 shell 中，可使用 export 命令来创建环境变量（C shell 使用 setenv 命令），如下所示：
```
$ export MYVAR='hello world'
```

#### 资源限制

每个进程都会消耗诸如打开文件、内存以及 CPU 时间之类的资源。使用系统调用 setrlimit()，进程可为自己消耗的各类资源设定一个上限。此类资源限制的每一项均有两个相关值：软限制（soft limit）限制了进程可以消耗的资源总量，硬限制（ hard limit）软限制的调整上限。非特权进程在针对特定资源调整软限制值时，可将其设置为 0 到相应硬限制值之间的任意值，但硬限制值则只能调低，不能调高。  

由 fork()创建的新进程，会继承其父进程对资源限制的设置。  

使用 ulimit 命令（在 C shell 中为 limit）可调整 shell 的资源限制。 shell 为执行命令所创建的子进程会继承上述资源设置。


## 内存映射

调用系统函数 mmap()的进程，会在其虚拟地址空间中创建一个新的内存映射。  

映射分为两类：
- 文件映射：将文件的部分区域映射入调用进程的虚拟内存。映射一旦完成，对文件映射内容的访问则转化为对相应内存区域的字节操作。映射页面会按需自动从文件中加载
- 无文件与之相对应的匿名映射，其映射页面的内容会被初始化为 0。

由某一进程所映射的内存可以与其他进程的映射共享。达成共享的方式有二：其一是两个进程都针对某一文件的相同部分加以映射，其二是由 fork()创建的子进程自父进程处继承映射。当两个或多个进程共享的页面相同时，进程之一对页面内容的改动是否为其他进程所见呢？这取决于创建映射时所传入的标志参数。若传入标志为私有，则某进程对映射内容的修改对于其他进程是不可见的，而且这些改动也不会真地落实到文件上；若传入标志为共享，对映射内容的修改就会为其他进程所见，并且这些修改也会造成对文件的改动。内存映射用途很多，其中包括：以可执行文件的相应段来初始化进程的文本段、内存（内容填充为 0）分配、文件 I/O（即映射内存 I/O）以及进程间通信（通过共享映射）。  



## 进程间通信IPC

方式有：
- 信号（ signal），用来表示事件的发生。
- 管道（亦即 shell 用户所熟悉的“ |”操作符）和 FIFO，用于在进程间传递数据。
- 套接字，供同一台主机或是联网的不同主机上所运行的进程之间传递数据。
- 文件锁定，为防止其他进程读取或更新文件内容，允许某进程对文件的部分区域加以锁定。
- 消息队列，用于在进程间交换消息（数据包）。
- 信号量（ semaphore），用来同步进程动作。
- 共享内存，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容时，其他所有进程会立即了解到这一变化。

贴士：就本质而言， FIFO和 UNIX 套接字功能相同，允许同一系统上并无关联的进程彼此交换数据。二者之所以并存于现代 UNIX 系统之中，是由于 FIFO 来自 System V，而套接字则源于 BSD  

## 线程

每个进程都可执行多个线程。可将线程想象为共享同一虚拟内存及一干其他属性的进程。每个线程都会执行相同的程序代码，共享同一数据区域和堆。可是，
每个线程都拥有属于自己的栈，用来装载本地变量和函数调用链接信息。  

线程之间可通过共享的全局变量进行通信。借助于线程 API 所提供的条件变量和互斥机制，进程所属的线程之间得以相互通信并同步行为—尤其是在对共享变量的使用方面。此外，  利用 IPC 和同步机制，线程间也能彼此通信。  

线程的主要优点在于协同线程之间的数据共享（通过全局变量）更为容易，而且就某些算法而论，以多线程来实现比之以多进程实现要更加自然。再者，显而易见，多线程应用能从多处理器硬件的并行处理中获益匪浅。

## 进程组和 shell 任务控制

shell 执行的每个程序都会在一个新进程内发起。比如， shell 创建了 3 个进程来执行以下管道命令（在当前的工作目录下，根据文件大小对文件进行排序并显示）：

```
$ ls -l | sort -k5n | less
```

在支持任务控制的 shell 中，会将管道内的所有进程置于一个新进程组或任务中。（如果情况很简单， shell 命令行只包含一条命令，那么就会
创建一个只包含单个进程的新进程组。 ）进程组中的每个进程都具有相同的进程组标识符（以整数形式），其实就是进程组中某个进程（也称为进程组组长 process group leader）的进程 ID。  

内核可对进程组中的所有成员执行各种动作，尤其是信号的传递。

## 会话、控制终端和控制进程

会话指的是一组进程组（任务）。会话中的所有进程都具有相同的会话标识符。会话首进程（ session leader）是指创建会话的进程，其进程 ID 会成为会话 ID  

使用会话最多的是支持任务控制的 shell，由 shell 创建的所有进程组与 shell 自身隶属于同一会话， shell 是此会话的会话首进程。  

在任一时点，会话中总有一个前台进程组（前台任务），可以从终端中读取输入，向终端发送输出:  

如果用户在控制终端中输入了“中断”（通常是 Control-C）或“挂起”字符（通常是 Control-Z），那么终端驱动程序会发送信号以终止或挂起（亦即停止）前台进程组。  

一个会话可以拥有任意数量的后台进程组（后台任务），由以“ &”字符结尾的行命令来创建。支持任务控制的 shell 提供如下命令：列出所有任务，向任务发送信号，以及在前后台任务之间来回切换.  

伪终端：伪终端是一对相互连接的虚拟设备，也称为主从设备。在这对设备之间，设有一条 IPC信道，可供数据进行双向传递，比如市面上的ssh软件。  

## 进程与实践

- 真实时间：进程的生命周期时间  
- 进程时间：也称为CPU时间，指进程自启动起来，所占用cpu时间总量
  - 系统CPU时间：内核模式中，执行代码花费的时间，比如执行系统调用
  - 用户CPU时间：用户模式中，执行代码花费的时间，比如常规代码运行

time命令会显示出真实时间、系统CPU时间，以及执行管道中的多个进程花费的用户CPU时间。  


## 实时性

为支持实时性应用， POSIX.1b 定义了多个 POSIX.1 扩展，其中包括异步 I/O、共享内存、内存映射文件、内存锁定、实时性时钟和定时器、备选调度策略、实时性信号、消息队列、以及信号量等

## /proc文件系统

/proc 文件系统装配与 /proc 目录下。  

/proc 文件系统是一种虚拟文件系统，以文件系统目录和文件形式，提供一个指向内核数据结构的接口。  

这为查看和改变各种系统属性开启了方便之门。此外，还能通过一组以/proc/PID 形式命名的目录（ PID 即进程 ID）查看系统中运行各进程的相关信息。
通常， /proc 目录下的文件内容都采取人类可读的文本形式， shell 脚本也能对其进行解析。  

程序可以打开、读取和写入/proc 目录下的既定文件。大多数情况下，只有特权级进程才能修改/proc 目录下的文件内容。  


## 操作系统模型

系统模型：计算机用操作系统来管理所有的资源，并将不同的设备和不同的程序连接起来。有了操作系统后，多用户的连接，各种数据读写操作才能得到有效的控制和管理。  

贴士：操作系统 也是程序，与普通程序一样，运行在内存中，同时它也是一个特殊的程序，能够把普通程序与其他程序、设备连接起来。

有了系统模型，计算机的内存空间就会被划分为两部分：
- 用户空间：容纳应用程序的内存空间，所有的程序都必须在内存空间中才能运行
- 系统空间：容纳操作系统的内存空间，也可以称为内核

必须通过内核，程序要访问设备（键盘、磁盘等），因为只有内核才能直接管理设备。

## 系统资源

内核用来管理资源，那么操作系统有哪些资源：
- 1.处理器（Processor）：执行指令（程序）的硬件设备，有1到多个，内核可以安排一个程序何时执行，何时暂停，何时恢复，何时终止
- 2.输入输出（I/O):终端、程序、硬盘等地方的输入/输出数据都会经过内核，这样的好处是：
  - 数据流不会流错地方
  - 开发者不需要考虑不同的设备差异
  - 数据信息不会被未授权的程序非法访问
- 3.进程管理（Process Management）：进程代表一个程序的运行，进程内包含了该程序的资源：内存、打开的文件、运行时所需系统资源，内核可以新建进程、终止进程、调度进程
- 4.内存（Memory）：只有加载到内存的程序才可以运行。内核在需要的时候回给程序分配内存、回收内存，并能保证内存不被其他进程非法访问
- 5.设备（Device）：内核能够屏蔽光驱、鼠标、扫描仪等外设的差异，如：一个程序想要从计算机中拷贝照片到移动硬盘中，只需要向内核提出操作该资源的请求即可
- 6.计时器（Timers）：程序的工作与实践有关，有时需要定时被处罚，有时需要等待，有时需要知道运行消耗实践，内核可以通过系统调用向程序提供计时器服务
- 7.进程间通信（Interprocess Communication）：各个进程之间需要通信，内核为通信提供一系列方式
- 8.网络（Networking）：不同主机的进程，即使使用不同的操作系统也可以互相通信，内核会提供通信的标准服务

Unix系统编程中重要的三个方面：
- 通信：某个用户或者进程如何与其他用户或进程交换信息
- 协作：程序如何协调多个进程使他们能够没有冲突的访问共享资源
- 网络：不同计算机之间通过网络连接到一起，计算机中的程序如何使用网络访问其他计算机的资源


## 信号

Ctrl+C可以终止一个正在运行的程序，这个中断是由一个内核机制产生，该机制即信号。  

Ctrl+C产生的信号工作机制：
- 1 驱动程序收到Ctrl+C产生的字符（可以是Ctrl-C，也可以是stty，tcsetattr）
- 2 匹配VINTR和ISIG的字符被开启
- 3 驱动程序调用信号系统
- 4 信号系统发送SIGINT到进程
- 5 进程收到SIGINT
- 6 进程消亡

信号：由单个词组成的消息，比如中断信号通常是编码2。  

信号来自内核，但是信号的请求来自三个地方：
- 用户：比如Ctrl-C，或者一些终端驱动产生
- 内核：进程执行出错，内核会向进程发送信号，如浮点数溢出等
- 进程：进程可以通过kill给另一个进程发送信号（其实信号是进程间通信的方式之一）

信号的分类：
- 同步信号（synchronous signals）：由进程的某个操作产生的信号，如：被零除
- 异步信号（asynchronous signals）：由进程外的事件引起的信号，如：用户输入Ctrl-C

liunx中，信号的定义位于`/usr/inlude/signal.h`文件中，如下所示：
```
# define SIGHUP     1
# define SIGINT     2
# define SIGQUIT    3
...
```
SIGINT即是中断信号

## 信号处理模型：进程如何处理信号

比如进程接收到信号SIGINT（终止信号），并不是一定会消亡，进程能够通过系统调用signal告诉内核，该如何处理信号，进程有三种选择：
- 选择1：默认选择（通常会消亡），调用函数为：`signal(SIGINT, SIG_DFL)`
- 选择2：忽略信号，程序调用方法`signal(SIGINT, SIG_IGN)`告诉内核忽略掉SIGINT信号
- 选择3：调用一个函数，该函数被称为信号处理函数，`signal(signum, functionname)`

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

int main() {

    void handler(int);          // 声明信号处理函数
    signal(SIGINT, handler);    // 装载信号处理函数

    int i;
    for(i = 0; i < 100; i++) {
        printf("i==%d\n", i);
        sleep(1);
    }
}

void handler(int signum) {
    printf("handle.... \n");
}
```

上述函数在运行时，使用Ctrl-C发送信号后，程序将会打印：`handle.....`，示例中并没有对handler函数进行显示调用。 

同理，如果signal函数这样书写，则Ctrl-C对程序不会产生影响：
```c
signal(SIGINT, SIG_IGN);
```

## 多信号处理模型

如果只有一个信号要处理，上述原始的信号处理模型足以应付。如果有多个信号到达呢？信号的响应如果是终止或者忽略，则结果很清晰，但是响应式调用一个函数，那么结果会产生影响：

问题一 捕鼠器问题：老鼠被捕获后，捕鼠器就失效了，信号处理函数也是，所以每次捕获信号后，都要重新设置。  
```c
// 为解决捕鼠器问题，信号处理函数可能如下：
void handler(int s) {
    signal(SIGINT, handler);        // 重设处理函数，造成信号捕获后，要先重设处理函数，再执行业务逻辑
    ...                             // 业务处理逻辑    
}

```

就算信号重设的再快，也是耗时的，这时候有可能出现：弹簧被处罚和设置完成之间，老鼠溜走了。这个间隙让信号处理不可靠，称为：不可靠信号。  

问题二：进程在处理一个信号时候，其他到达信号就会阻塞，如果多个信号同时到达，该如何处理：  

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>

int main(int ac, char *av[]) {

    void intHandler(int);
    void quitHandler(int);

    char input[100];
    int nchars;

    signal(SIGINT, intHandler);
    signal(SIGQUIT, quitHandler);

    do {
        printf("\nType a msg\n");
        nchars = read(0, input, 100 - 1);
        if(nchars == -1) {
            perror("read returned an error");
        } else {
            input[nchars] = '\0';
            printf("You typed: %s", input);
        }
    } while( strncmp(input, "quit", 4) != 0);
   
}

void intHandler(int s) {
    printf("Received signal %d .. waiting\n", s);
    sleep(2);
    printf(" Leaving intHandler \n");
}

void quitHandler(int s) {
    printf("Received signal %d .. waiting\n", s);
    sleep(3);
    printf(" Leaving quitHandler \n");
}
```

这时，可以如下操作：
- 同时发出多次 Ctrl-C：会阻塞后续的相同信号
- 发出Ctrl-C后，瞬间发出Ctrl-\：程序会先进入intHandler，再进入quitHandler，再回到intHandler，最后回到主循环。
- 输入文字后，再按Ctrl-C，在输入文字：程序在执行时，收到中断信号，Unix经典模式中是返回并设置EINTR为-1

旧时代信号系统仍然被支持，但是也有新的信号系统，比如POSIX模型中的signaction替代了signal：
```c
signaction(signalnumber, signalaction, prevaction);       # 新操作设置成功返回0，否则返回-1
```
参数一：指定要处理的消息  
参数二：指向如何响应信号的结构体  
参数三：如果不是null，则指向被替换的处理设置的结构体

示例：
```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>

int main(int ac, char *av[]) {

    struct sigaction newHandler;
    sigset_t        blocked;
    void            intHandler();
    char            x[100];

    newHandler.sa_handler = intHandler;
    newHandler.sa_flags = SA_RESETHAND;

    sigemptyset(&blocked);
    sigaddset(&blocked, SIGQUIT);
    newHandler.sa_mask = blocked;

    if(sigaction(SIGINT, &newHandler, NULL) == -1){
        perror("sigaction");
    } else {
        while(1){
            fgets(x, 100, stdin);
            printf("input: %s", x);
        }
    }
   
}

void intHandler(int s) {
    printf("Called with signal %d \n", s);
    sleep(s);
    printf("Done handing signal %d\n", s);
}
```

如果以很快的速度连续按Ctrl-C和Ctrl-\，退出信号将被阻塞直到中断信号处理完毕。  
如果连续按两下Ctrl-C，进程就被第二个信号杀死。  
如果想要捕获所有的Ctrl-C，将SA-RESETHAND掩码从sa_flags中去掉。  

## 临界区

如果某段代码在修改数据时被打断，就会造成数据的不完整，则称这段代码临界区。  

程序在处理信号时，必须决定哪一段代码是临界区，然后设法保护这段代码。但是很多临界区不一定就在信号处理函数中，而是在常规程序流中，保护临界区的简单办法是阻塞或忽略那些处理函数将要使用或者修改特定数据的信号。  

可以在信号处理者一级或者进程一级阻塞信号。  

#### 在信号处理者一级阻塞信号

为了在处理一个信号的时候阻塞另一个信号，要设置struct sigaction结构中的sa_mask成员位，它在设置处理函数时被传递给sigaction。 sa_mask是sigset_t类型，定义了一个信号集。

#### 进程的信号阻塞

进程一直都有一些信号被阻塞，这些信号集称为信号挡板（signal mask），通过sigprocmask可以修改这个被阻塞的信号集，sigprocmask本身也是一个原子操作：
```c
int res = sigprocmask(int how, const sigset_t * sigs, sigset_t * prev);     // 返回值为0则成功，-1为失败
```
参数：
- how：如何修改信号挡板
- sigs：指向使用的信号列表的指针
- prev：指向之前的信号挡板列表的指针或者为null

当how值分别为SIG_BLOCK,SIG_UNBLOCK,SIG_SET时候，* sigs所指定的信号将被添加、删除、替换。如果 prev不是null，那么之前的信号挡板设置将被赋值到*prev中。  

#### sigsetops构建信号机

一个sigset_t是一个抽象的信号集，可以通过一些函数来添加或删除信号，基本函数如下：
```c
sigemptyset(sigset_t * setp);           // 清除由setp指向的列表中的所有信号
sigfillset(sigset_t * setp);            // 添加所有的信号到setp指向的类表
sigaddset(sigset_t *setp, int signum);  // 添加signum到setp指向的列表
sigdelset(sigset_t *setp, int signum);  // 从setp指向的列表中删除signum所标识的信号
```

## kill 从另一个进程发送信号

进程可以通过kill系统调用向另一个进程发送信号：
```c
int kill(pid_t pid, int sig);
```
## 未定义信号

Unix有两个信号SIGUSR1和SIGUSR2，没有预定义任务，可以被用户程序使用。  

## 程序的运行

一个程序是存储在文件中的机器指令序列，由编译器将源码编译成二进制文件后，可以运行。运行该程序意味着将这个机器指令序列载入内存然后让处理器逐条执行。  

在Unix中，一个可执行程序是一个机器指令及其数据序列，一个进程是程序运行时的内存空间和设置。  

进程位于用户空间，通过ps(process status)命令查看，每个进程都有一个可以唯一标识的数字，称为PID（进程ID）。
```
ps      #  列出进程
ps -a   #  列出所有进程，包括其他终端、其他用户运行的程序，但并不包括shell进程，-l可以打印更多细节
```

S：代表进程状态，值为R表示进程正在运行，S表示处于睡眠状态
UID：表示该进程所对应的用户
PRI和NI：分别是进程的由县级和niceness级，内核根据这些值来决定什么时候运行进程，一个进程可以增加niceness级别，（类似排队时被安排到更前位置）。
SZ：进程占据内存的大小。
WCHAN：进程睡眠原因，其值read_c或do_sel代表内核地址   


内存可以看做是一个容纳内核和进程的空间，很多系统把内存看做由页面构成的数组，将继承分割到不同的页面，物理上，这些页面存储在固体的芯片中。  
内存实际上是一个字节序列，或者说是一个很大的数组，如果机器有64M内存，那么这个数组大约有6700万个内存位置，其中一些用来存放组成内核的机器指令和数据。   

建立一个进程类似于建立一个磁盘文件，内核要找到一些用来存放程序指令和数据的空闲页，还要额外建立数据结构来存储响应的内存分配情况、进程属性等。  

一个程序运行另外一个程序调用：execvp
建立新的进程：fork