## 一  指针概述

如果在程序中定义了一个变量，在对程序进行编译时，系统会给这个变量分配内存单元，编译系统根据变量类型，分配一定长度的空间。  

指针：变量的地址即指针。  

通过变量名进行对变量的访问是直接访问方式，还可以使用间接访问方式：将变量地址存放在另外一个变量中，通过该变量来找到原变量的地址，从而访问到元变量。  

```c
    int i = 5;

    // 通过变量名直接访问
    printf("i=%d\n", i);

    // 通过指针间接访问
    int * i_ptr = &i;            // 将i的地址存储到指针变量 i_ptr， i是基类型
    printf("i=%d\n", * i_ptr);  // 获取指针变量的地址指向的数据值

    return 0;
```

基类型可以是int，float，double，必须对指针类型指定基类，因为如果不指定，无法判定是从一个地址为2000的一个字节中取出一个字符数据还是从2000-2010取出short型数据等等。  

指向函数的指针：函数在编译时，编译系统为函数代码分配一段存储孔家，这段存储空间的起始地址（入口地址）称为这个函数的指针。  
```c
#include <stdio.h>

int main() {

    int addOne(int);
    int (* p) (int);
    p = addOne;

    int r;
    r = ( * p)(3);
    printf("r=%d\n", r);

    return 0;
}

int addOne(int x) {
    return x + 1;
}
```


## 二 内存动态分配

#### 2.0 栈与堆

非静态的局部变量（包括形参）是分配在内存中的动态存储区的，这个存储区一般称为栈（stack）。  

C语言还允许建立内存动态分配区域，以存放一些临时用的数据，这些数据不必在程序的声明部分定义，也不必等到函数结束时释放，而是需要随时开辟，不需要时随时释放。这些数据是临时存放在一个特别的自由存储区，称为堆（heap）。  

对内存动态分配是通过系统的库函数来实现的，主要有：malloc，calloc，free，realloc4个函数。  

#### 2.1 malloc

malloc用于在内存的动态存储区中分配一个长度为size的连续空间，其形参size是个无符号整数（即不能是负数），函数返回值是所分配区域的第一个字节的地址，或者说次函数是一个指针型函数，返回的指针指向该分配域的开头位置：
```c
// 函数原型： void * malloc(unsigned int size);

malloc(100)     // 开辟100字节临时分配域，函数值为其第1个字节的地址，如果执行失败（如内存不足），则返回空指针NULL。
```

#### 2.2 calloc

calloc作用是在内存的动态存储区中分配n个长度为size的连续空间，这个空间一般比较大，足以保存一个数组。  

用calloc函数可以为一维数组开辟动态存储空间，n为数组元素个数，每个元素长度为size，这就是动态数组，函数返回指向所分配域的起始位置的指针，如果分配不成功，返回NULL。

```c
// 函数原型 void * calloc(unsigned n, unsigned size);
p = calloc(50,5);   // 开辟50*4个字节临时分配域，把起始地址复制给指针变量p
```

#### 2.3 free

free函数作用是释放指针变量p所指向的动态空间，使这部分空间能够重新被其他变量所使用，p应该是最近一次调用calloc或malloc函数时得到的函数返回值。  


```c
// 原型： void free(void * p);
free(p);            // 释放指针变量p所指向的已分配的动态空间
```

#### 2.4 realloc

如果已经通过malloc函数或者calloc函数获得动态空间，想要改变大小，可以用realloc重新分配。
```c
// 原型为： void * realloc(void *p, unsigned int size);
realloc(p, 50);         // 将p所指向的已分配的动态空间改为50 字节
```

##### 2.5 说明

以前的C提供的malloc和calloc得到的是指向字符型数据的指针，原型为：`char * malloc(unsigned int size);` ，但实际上，这些空间不一定是用来存放字符的，如果把开辟的区域用来存放整数，则要进行类型转换：

```c
int * ptr;
ptr = (int *) malloc(100);  // 将指向字符数据的指针转换为指向整型数据的指针
```

C99标准将上述函数的基类型定位void，即无类型指针（typeless pointer），表示用来指向一个抽象的类型的数据，即仅仅提供一个纯地址，而不指向任何具体的对象。

##### 2.6 void指针类型

C99允许使用基类型为void的指针类型，即该指针不指向任何类型的数据：
```c
    int a = 3;
    int * p1 = &a;
    void * p2;
    p2 = (void *)p1;        // 正确
    p2 = &a;                // 错误，因为p2无指向
```



