## 一 函数概述

C语言的库提供了许多常用函数，使用库函数必须引入库文件，如：
```c
#include <math.h>
```
======TODO=====

## 二 函数原型

被调函数位于当前函数之前，可以直接调用：
```c
#include <stdio.h>

void myprint() {
    printf("hhh\n");
}

int main() {
    myprint();
    return 0;
}
```

被调函数位于当前函数之后，需要先声明再调用：
```c
#include <stdio.h>

int main() {
    void myprint();         // 声明
    myprint();              // 调用
    return 0;
}

void myprint() {
    printf("hhh\n");
}
```

函数的声明和函数的定义首行（称为函数原型：function prototype）是基本一样的（有没有分号的区别）。其中，函数声明中的形参具体名可省略不屑。  

声明（declaration）的作用是把函数名、函数参数的个数、类型等信息通知编译系统，以便遇到函数调用时，编译系统能够正确识别函数并检查调用是否合法。  

## 三 递归调用

调用一个函数的过程中，再次调用了函数本身，即为递归调用。递归调用必须可以终止，只能出现有限次数，否则会出现内存溢出情况。  

示例-递归解决汉诺塔问题（Hanoi）：

```
问题描述：

梵塔内有3个座位：A,B,C，A座上有64个大小不等的盘子，小的在上，大的在上
和尚想把这64个盘子从A座移动到C座，每次只能移动一个盘子，移动过程中，3个座位上都只能保持大盘在下，小盘在上
编程输出移动盘子的步骤。

解题思路：
1-加入有第二个和尚，命令第二个和尚将63个盘子移动到B座
2-自己讲第64个盘子（最大的那个）移动到C座
3-命令第二个和尚将63个盘子从B座移动到C座
```

代码：
```c
#include <stdio.h>

int main() {
    void hanoi(int n, char one, char two, char three);
    hanoi(46, 'A', 'B', 'C');
}

void hanoi(int n, char one, char two, char three) {
    void move(char x, char y);
    if (n == 1) {
        printf("%c-->%c\n", one, three);
    } else {
        hanoi(n - 1, one, three, two);
        printf("%c-->%c\n", one, three);
        hanoi(n - 1, two, one, three);
    }
}
```

## 四 数组作为函数参数

数组名作为参数传递时，传递是数组的第一个元素的地址。

## 五 变量的存储

#### 5.0 存储方式

从变量值存在的时间（生命周期）看，可以分为：
- 静态存储方式：程序运行期间由系统分配固定的存储空间，使用static修饰
- 动态存储方式：程序运行期间根据需要动态分配的存储空间

在定义和声明变量、函数时，一般需要同时指定其数据类型和存储类别，也可以采用默认指定方式：
- auto：自动的
- static：静态的
- register：寄存器的
- extern：外部的

#### 5.1 自动变量 auto

如果函数中的局部变量，不专门声明为static存储类别，都是动态分配，即数据存储在动态存储区，例如函数的形参。调用该函数时，系统会给这些变量分配存储空间，在函数调用结束时就自动释放这些存储空间，因此这类局部变量称为自动变量。  

贴士：auto可以省略，不写则隐含自定为自动存储类别，属于动态存储方式。

#### 5.2 静态局部变量 static

如果希望局部变量的值在哈数调用结束后不消失，即占用的存储单元不被释放，可以使用static声明。

#### 5.3 寄存器变量 register

一般情况下，变量的值存放在内存中，当程序中使用到了哪一个变量的值，由控制器发出指令将内存中该变量的值送到运算器中，经过运算器进行运算，如果需要存数，再从运算器将数据送到内存存放。  

如果有些变量使用频繁，存取变量会花费不少时间，为了提高效率，允许将局部变量的值放在CPU的寄存器中，需要时，直接从寄存器取出参与运算，这样的操作速度极高。

总结：
- 自动变量存储在动态存储区
- 静态局部变量存储在静态存储区
- 寄存器变量存储在CPU的寄存器中

## 六 全局变量类别

全局变量是存放在静态存储区中的，因为其生存期固定，存在于程序的整个运行过程。其作用于是从变量的定义初开始直到本程序文件的末尾。  

但如果需要扩展作用域，需要考虑以下情况：

#### 6.1 在文件内扩展外部变量的作用域

如果外部变量不在文件的开头定义，其有效的作用范围只限于定以处到文件结束，在定义点之前的函数不能引用该外部变量，如果由于某种考虑，在定义点之前的函数需要引用该外部变量，则应该在引用之前用关键字extern对该变量作“外部变量声明”，表示把该外部变量的作用域扩展到此位置，有了该声明，就可以从声明处起，合法使用该外部变量：
```c
#include <stdio.h>

int main() {
    int max();
    extern int A,B;
    scanf("%d %d", &A, &B);
    printf("%d\n", max());
    return 0;
}

int A,B;

int max() {
    return A>B?A:B;
}

```

#### 6.2 扩展外部变量作用域到其他文件

main.c：
```c
#include <stdio.h>
#include "./file.c"

int A;

int main() {

    int test(int);

    int num = 3;
    int r = 0;
    A = 5;

    r = test(num);
    printf("r=%d\n", r);
    return 0;
}
```

file.c:
```c
extern int A;
int test(int i) {
    return i + A;
}
```

#### 6.3 将外部变量的作用域限制在本文件

变量添加一个static修饰即可，此时该变量只能限于本文件引用。

#### 6.4 小结

作用域角度划分：
- 局部变量
  - 动态局部变量：即自动变量，离开函数，值消失
  - 静态局部变量：离开函数，值保留
  - 寄存器变量：离开函数，值消失
- 全局变量
  - 静态外部变量：限制在本文件使用
  - 外部变量：允许其他文件引用

贴士：形参可以定义为自动变量或寄存器变量  

生命周期划分：
- 动态存储
  - 自动变量
  - 寄存器变量
  - 形参
- 静态存储
  - 静态局部变量
  - 静态外部变量

static：
- 修饰局部变量：是变量从动态存储改为静态存储方式
- 修饰全局变量：使文件不能被外部文件引用
- 修饰函数：函数只能被本文件引用，称为内部函数

贴士：sextern修饰的函数为外部函数，可以供其他文件调用，是函数默认的修饰。




