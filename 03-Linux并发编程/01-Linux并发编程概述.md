## 内核简介

操作系统往往有两种含义：
- 指完整的软件包，这包括用来管理计算机资源的核心层软件，以及附带的所有标准软件工具，诸如命令行解释器、图形用户界面、文件操作工具和文本编辑器等
- 在更狭义的范围内，是指管理和分配计算机资源（即 CPU、 RAM 和设备）的核心层软件，该含义我们通常称为内核。  

在没有内核的情况下，计算机也能运行程序，但有了内核会极大简化其他程序的编写和使用，因为内核为管理计算机的有限资源提供了软件层。  

内核名称：
- 早期UNIX实现称内核为UNIX
- 实现了虚拟内存机制的 UNIX 系统中，其内核名称变更为 vmunix
- Linux 内核可执行文件采用/boot/vmlinuz 或与之类似的路径名


##  内核职责

####  进程管创建、删除、调度

内核可将新程序载入内存，为其提供运行所需的资源（比如， CPU、内存以及对文件的访问等）。这样一个运行中的程序我们称之为“进程”。一旦进程执行完毕，内核还要确保释放其占用资源，以供后续程序重新使用。  

计算机内均配备有一个或多个 CPU（中央处理单元），以执行程序指令。与其他 UNIX 系统一样， Linux 属于抢占式多任务操作系统。 “多任务”意指多个进程（即运行中的程序）可同时驻留于内存，且每个进程都能获得对 CPU 的使用权。“抢占”则是指一组规则。这组规则控制着哪些进程获得对 CPU 的使用，以及每个进程能使用多长时间，这两者都由内核进程调度程序（而非进程本身）决定。  



#### 内存管理

物理内存（ RAM）属于有限资源，内核必须以公平、高效地方式在进程间共享这一资源。  

与大多数现代操作系统一样， Linux也采用了虚拟内存管理机制，其优势有：
- 进程与进程之间、进程与内核之间彼此隔离，因此一个进程无法读取或修改内核或其他进程的内存内容
- 只需将进程的一部分保持在内存中，这不但降低了每个进程对内存的需求量，而且还能在 RAM 中同时加载更多的进程。这也大幅提升了如下事件的发生概率，在任一时刻， CPU 都有至少一个进程可以执行，从而使得对 CPU 资源的利用更加充分

#### 文件系统

内核在磁盘之上提供有文件系统，允许对文件执行创建、获取、更新以及删除等操作

#### 支持外部设备访问

计算机外接设备（鼠标、键盘、磁盘和磁带驱动器等）可实现计算机与外部世界的通信，这一通信机制包括输入、输出或是两者兼而有之。内核既为程序访问设备提供了简化版的标准接口，同时还要仲裁多个进程对每一个设备的访问。

#### 网络支持

内核以用户进程的名义收发网络消息（数据包）。该任务包括将网络数据包路由至目标系统。

#### 提供系统调用应用编程接口（ API）

进程可利用内核入口点（也称为系统调用）请求内核去执行各种任务。

#### 虚拟私有计算机（ virtual private computer）

Linux 之类的多用户操作系统会为每个用户营造一种抽象：虚拟私有计算机（ virtual private computer）。这就是说，每个用户都可以登录进入系统，独立操作，而与其他用户大致无干。例如，每个用户都有属于自己的磁盘存储空间（主目录）。再者，用户能够运行程序，而每一程序都能从 CPU 资源中“分得一杯羹”，运转于自有的虚拟地址空间中。而且这些程序还能独立访问设备，并通过网络传递信息。内核负责解决（多进程）访问硬件资源时可能引发的冲突，用户和进程对此则往往一无所知。  

## 内核态和用户态

现代处理器架构一般允许 CPU 至少在两种不同状态下运行，即：用户态和核心态（有时也称之为监管态 supervisor mode）。  

执行硬件指令可使 CPU 在两种状态间来回切换。与之对应，可将虚拟内存区域划分（标记）为用户空间部分或内核空间部分。在用户态下运行时， CPU 只能访问被标记为用户空间的内存，试图访问属于内核空间的内存会引发硬件异常。当运行于核心态时， CPU 既能访问用户空间内存，也能访问内核空间内存。  

仅当处理器在核心态运行时，才能执行某些特定操作。这样的例子包括：执行宕机（halt）指令去关闭系统，访问内存管理硬件，以及设备 I/O 操作的初始化等。实现者们利用这一硬件设计，将操作系统置于内核空间。这确保了用户进程既不能访问内核指令和数据结构，也无法执行不利于系统运行的操作。  


一个运行系统通常会有多个进程并行其中。对进程来说，许多事件的发生都无法预期。执行中的进程不清楚自己对 CPU 的占用何时“到期”，系统随之又会调度哪个进程来使用CPU（以及以何种顺序来调度），也不知道自己何时会再次获得对 CPU 的使用。信号的传递和进程间通信事件的触发由内核统一协调，对进程而言，随时可能发生。诸如此类，进程都
一无所知。进程不清楚自己在 RAM 中的位置。或者换种更通用的说法， 进程内存空间的某块特定部分如今到底是驻留在内存中还是被保存在交换空间（磁盘空间中的保留区域，作为计算机 RAM 的补充）里，进程本身并不知晓。与之类似，进程也闹不清自己所访问的文件“居于”磁盘驱动器的何处，只是通过名称来引用文件而已。进程的运作方式堪称“与世隔绝” —进程间彼此不能直接通信。进程本身无法创建出新进程，哪怕“自行了断”都不行。最后还有一点，进程也不能与计算机外接的输入输出设备直接通信。

相形之下，内核则是运行系统的中枢所在，对于系统的一切无所不知、无所不能，为系统上所有进程的运行提供便利。由哪个进程来接掌对 CPU 的使用，何时“接任”， “任期”多久，都由内核说了算。在内核维护的数据结构中，包含了与所有正在运行的进程有关的信息。随着进程的创建、状态发生变化或者终结，内核会及时更新这些数据结构。内核所维护的底层数据结构可将程序使用的文件名转换为磁盘的物理位置。此外，每个进程的虚拟内存与计算机物理内存及磁盘交换区之间的映射关系，也在内核维护的数据结构之列。进程间的所有通信都要通过内核提供的通信机制来完成。响应进程发出的请求，内核会创建新的进程，终结现有进程。最后，由内核（特别是设备驱动程序） 来执行与输入/输出设备之间的所有直接通信， 按需与用户进程交互信息。

## shell

shell 是一种具有特殊用途的程序，主要用于读取用户输入的命令，并执行相应的程序以响应命令。有时，人们也称之为命令解释器。  

尽管某些操作系统将命令解释器集成于内核中，而对 UNIX 系统而言， shell 只是一个用户进程。   

常见shell：
- Bourne shell（ sh）： Steve Bourne 编写，历史悠久，是第七版UNIX的标配shell，包含特性有：I/O 重定向、管道、文件名生成（通配符）、变量、环境变量处理、命令替换、后台命令执行以及函数
- C shell（ csh）： Bill Joy 于加州大学伯克利分校编写而成，命名因为与C语法相似。csh与sh不兼容！
- Korn shell（ ksh）： AT&T 贝尔实验室的 David Korn 编写了这款 shell，保持了与 sh 兼容的同时，也吸收了 csh 交互式特性
- Bourne again shell（ bash）：这款 shell 是 GNU 项目对 Bourne shell 的重新实现。提供了与 C shell 和 Korn shel 所类似的交互式特性，Linux的上Bourne shell（ sh）其实正是由 bash 仿真提供的

## 用户和用户组

系统会对每个用户的身份做唯一标识，用户可隶属于多个组  

#### 用户

系统的每个用户都拥有唯一的登录名（用户名）和与之相对应的整数型用户 ID（UID）。系统密码文件/etc/passwd 为每个用户都定义有一行记录，除了上述两项信息外，该记录还包含如下信息：
- 组 ID：用户所属第一个组的整数型组 ID。
- 主目录：用户登录后所居于的初始目录。
- 登录 shell：执行以解释用户命令的程序名称。

该记录还能以加密形式保存用户密码。然而，出于安全考虑，用户密码往往存储于单独的 shadow 密码文件中，仅供特权用户阅读。  


#### 组


出于管理目的，尤其是为了控制对文件和其他资源的访问，将多个用户分组是非常实用的做法。例如，某项目的开发团队人员需要共享同一组文件，就可以将他们编为同一组的成员。在早期的 UNIX 实现中，一个用户只能隶属于一个组。 BSD 率先允许一个用户同时属于多个组，这一理念后来被其他 UNIX 实现纷纷效仿，并最终成为 POSIX.1-1990 标准。每个用户组都对应着系统组文件/etc/group 中的一行记录，该记录包含如下信息。
-  组名： （唯一的）组名称。
-  组 ID（ GID）：与组相关的整数型 ID。
-  用户列表：隶属于该组的用户登录名列表（通过密码文件记录的 group ID 字段未能标识出的该组其他成员，也在此列），以逗号分隔

#### 超级用户

超级用户账号的用户 ID 为 0，通常登录名为 root。超级用户凌驾于系统的权限检查之上。因此，无论对文件施以何种访问权限限制，超级用户都可以访问系统中的任何文件，也能发送信号干预系统运行的所有用户进程。系统管理员可以使用超级用户账号来执行各种系统管理任务。  

## 单根目录层级、目录、链接及文件

内核维护着一套单根目录结构，以放置系统的所有文件。（这与微软 Windows 之类的操作系统形成了鲜明对照， Windows 系统的每个磁盘设备都有各自的目录层级。 ）这一目录层级的根基就是名为“ /”的根目录。  

#### 文件类型

文件系统内，会对文件类型进行标记，以表明其种类。其中一种用来表示普通数据文件，人们常称之为“普通文件”或“纯文本文件”，以示与其他种类的文件有所区别。其他文
件类型包括设备、管道、套接字、目录以及符号链接。  

#### 文件的所有权和权限

每个文件都有一个与之相关的用户 ID 和组 ID，分别定义文件的属主和属组。系统根据文件的所有权来判定用户对文件的访问权限。  

为了访问文件，系统把用户分为 3 类：文件的属主（有时，也称为文件的用户）、与文件组（ group） ID 相匹配的属组成员用户以及其他用户。 可为以上 3 类用户分别设置 3 种权限（共计 9 种权限位）：只允许查看文件内容的读权限；允许修改文件内容的写权限；允许执行文件的执行权限。这里的文件要么指程序，要么是交由某种解释程序（通常指 shell 的一种，但也有例外）处理的脚本。也可针对目录进行上述权限设置，但意义稍有不同。读权限允许列出目录内容（即该目录下的文件名），写权限允许对目录内容进行更改（比如，添加、修改或删除文件名），执行（有时也称为搜索）权限允许对目录中的文件进行访问（但需受文件自身访问权限的约束）。  

## 文件 I/O 模型

UNIX 系统 I/O 模型最为显著的特性之一是其 I/O 通用性概念。也就是说，同一套系统调用（ open()、 read()、 write()、 close()等）所执行的 I/O 操作，可施之于所有文件类型，包括设备文件在内。 （应用程序发起的 I/O 请求，内核会将其转化为相应的文件系统操作，或者设备驱动程序操作，以此来执行针对目标文件或设备的 I/O 操作。 ）因此，采用这些系统调用的程序能够处理任何类型的文件。  

就本质而言，内核只提供一种文件类型：字节流序列，在处理磁盘文件、磁盘或磁带设备时，可通过 lseek()系统调用来随机访问。  

许多应用程序和函数库都将新行符（十进制 ASCII 码为 10，有时亦称其为换行）视为文本中一行的结束和另一行的开始。 UNIX 系统没有文件结束符的概念，读取文件时如无数据返回，便会认定抵达文件末尾。  

#### 文件描述符

I/O 系统调用使用文件描述符—（往往是数值很小的）非负整数—来指代打开的文件。获取文件描述符的常用手法是调用 open()，在参数中指定 I/O 操作目标文件的路径名。  

通常，由 shell 启动的进程会继承 3 个已打开的文件描述符：
- 标准输入：描述符为0，对应stdio函数库中的stdin，指代为进程提供输入的文件
- 标准输出：描述符为1，对应stdio函数库中的stdout，指代供进程写入输出的文件
- 标准错误：描述符为2，对应stdio函数库中的stderr，指代供进程写入错误消息或异常通告的文件


## 进程

进程是正在执行的程序实例。执行程序时，内核会将程序代码载入虚拟内存，为程序变量分配空间，建立内核记账（ bookkeeping）数据结构，以记录与进程有关的各种信息（比如，进程 ID、用户 ID、组 ID 以及终止状态等）。  

在内核看来，进程是一个个实体，内核必须在它们之间共享各种计算机资源。内核一开始会为进程分配一定数量的资源（如受限的内存），并在进程的生命周期内，
统筹该进程和整个系统对资源的需求，对这一分配进行调整。程序终止时，内核会释放所有此类资源，供其他进程重新使用。其他资源（如 CPU、网络带宽等）都属于可再生资源，但必须在所有进程间平等共享。  


逻辑上将一个进程划分为以下几部分（即在内存找那个的布局）：
- 文本：程序的指令。
- 数据：程序使用的静态变量。
- 堆：程序可从该区域动态分配额外内存。
- 栈：随函数调用、返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间。  

#### 创建进程

进程可使用系统调用 fork()来创建一个新进程。调用 fork()的进程被称为父进程，新创建的进程则被称为子进程。  

内核通过对父进程的复制来创建子进程。子进程从父进程处继承数据段、栈段以及堆段的副本后，可以修改这些内容，不会影响父进程的“原版”内容。 （在内存中被标记为只读的程序文本段则由父、子进程共享。 ）  

#### 进程执行程序

子进程被创建后：
- 要么去执行与父进程共享代码段中的另一组不同函数
- 要么使用系统调用 execve()去加载并执行一个全新程序。 execve()会销毁现有的文本段、数据段、栈段及堆段，并根据新程序的代码，创建新段来替换它们。  

贴士：实际上不存在exec()库函数，而是以此名称为基础，C语言提供了多个相关函数。   

#### 进程ID和父进程ID 

每一进程都有一个唯一的整数型进程标识符（ PID）。此外，每一进程还具有一个父进程标识符（ PPID）属性，用以标识请求内核创建自己的进程。  

#### 进程终止和终止状态

可使用以下两种方式之一来终止一个进程：
- 方式一：进程可使用_exit()系统调用（或相关的exit()库函数），请求退出，此时进程会指明自己的终止状态
- 方式二：向进程传递信号，将其“杀死”，此时根据信号类型设置进程终止状态

贴士：
- 退出的进程都会生成“终止状态”，一个非负小整数，可供父进程的wait()系统调用检测。  
- 有时会将传递进_exit()的参数称为进程的“退出状态”，以示与终止状态有所不同，后者要么指传递给_exit()的参数值，要么表示“杀死”进程的信号。

根据惯例，终止状态为 0 表示进程“功成身退”，非 0 则表示有错误发生。大多数 shell 会将前一执行程序的终止状态保存于 shell 变量$?中。  

#### 进程的用户和组标识符（凭证）

每个进程都有一组与之相关的用户 ID (UID)和组 ID (GID)，如下所示：
- 真实用户 ID 和组 ID：用来标识进程所属的用户和组。新进程从其父进程处继承这些 ID。登录 shell 则会从系统密码文件的相应字段中获取其真实用户 ID 和组 ID。
- 有效用户 ID 和组 ID：进程在访问受保护资源（比如，文件和进程间通信对象）时，会使用这两个 ID（并结合下述的补充组 ID）来确定访问权限。一般情况下，
进程的有效 ID 与相应的真实 ID 值相同。正如即将讨论的那样，改变进程的有效ID 实为一种机制，可使进程具有其他用户或组的权限。
- 补充组 ID：用来标识进程所属的额外组。新进程从其父进程处继承补充组 ID。登录shell 则从系统组文件中获取其补充组 ID。

#### 特权进程

特权进程是指有效用户 ID 为 0（超级用户）的进程。通常由内核所施加的权限限制对此类进程无效。   

“无特权”（或非特权）进程是指由其他用户运行的进程。此类进程的有效用户 ID 为非 0 值，且必须遵守由内核所强加的权限规则。  

由特权进程创建的进程，也可以是特权进程。例如，一个由 root（超级用户）发起的登录 shell。成为特权进程的另一方法是利用 set-user-ID 机制，该机制允许某进程的有效用户ID 等同于该进程所执行程序文件的用户 ID。  

#### 能力（Capabilities）

Linux 把传统上赋予超级用户的权限划分为一组相互独立的单元（称之为“能力”）。  

每次特权操作都与特定的能力相关，仅当进程具有特定能力时，才能执行相应操作。传统意义上的超级用户进程（有效用户 ID 为 0）则相应开启了所有能力。
赋予某进程部分能力，使得其既能够执行某些特权级操作，又防止其执行其他特权级操作。能力的命名以 CAP_为前缀，例如， CAP_KILL。

#### init进程

系统引导时，内核会创建一个名为 init 的特殊进程，即“所有进程之父”，该进程的相应程序文件为/sbin/init。系统的所有进程不是由 init（使用 frok()）“亲自”创建，就是由其后代进程创建。 init 进程的进程号总为 1，且总是以超级用户权限运行。谁（哪怕是超级用户）都不能“杀死” init 进程，只有关闭系统才能终止该进程。 init 的主要任务是创建并监控系统运行所需的一系列进程。   

#### 守护进程


守护进程指的是具有特殊用途的进程，系统创建和处理此类进程的方式与其他进程相同，但以下特征是其所独有的：
- “长生不老”。守护进程通常在系统引导时启动，直至系统关闭前，会一直“健在”。
- 守护进程在后台运行，且无控制终端供其读取或写入数据。

守护进程中的例子有 syslogd（在系统日志中记录消息）和 httpd（利用 HTTP 分发 Web 页面）

#### 环境列表

每个进程都有一份环境列表，即在进程用户空间内存中维护的一组环境变量。这份列表的每一元素都由一个名称及其相关值组成。由 fork()创建的新进程，会继承父进程的环境副本。这也为父子进程间通信提供了一种机制。当进程调用 exec()替换当前正在运行的程序时，新程序要么继承老程序的环境，要么在 exec()调用的参数中指定新环境并加以接收。  

在绝大多数 shell 中，可使用 export 命令来创建环境变量（C shell 使用 setenv 命令），如下所示：
```
$ export MYVAR='hello world'
```

#### 资源限制

每个进程都会消耗诸如打开文件、内存以及 CPU 时间之类的资源。使用系统调用 setrlimit()，进程可为自己消耗的各类资源设定一个上限。此类资源限制的每一项均有两个相关值：软限制（soft limit）限制了进程可以消耗的资源总量，硬限制（ hard limit）软限制的调整上限。非特权进程在针对特定资源调整软限制值时，可将其设置为 0 到相应硬限制值之间的任意值，但硬限制值则只能调低，不能调高。  

由 fork()创建的新进程，会继承其父进程对资源限制的设置。  

使用 ulimit 命令（在 C shell 中为 limit）可调整 shell 的资源限制。 shell 为执行命令所创建的子进程会继承上述资源设置。


## 内存映射

调用系统函数 mmap()的进程，会在其虚拟地址空间中创建一个新的内存映射。  

映射分为两类：
- 文件映射：将文件的部分区域映射入调用进程的虚拟内存。映射一旦完成，对文件映射内容的访问则转化为对相应内存区域的字节操作。映射页面会按需自动从文件中加载
- 无文件与之相对应的匿名映射，其映射页面的内容会被初始化为 0。

由某一进程所映射的内存可以与其他进程的映射共享。达成共享的方式有二：其一是两个进程都针对某一文件的相同部分加以映射，其二是由 fork()创建的子进程自父进程处继承映射。当两个或多个进程共享的页面相同时，进程之一对页面内容的改动是否为其他进程所见呢？这取决于创建映射时所传入的标志参数。若传入标志为私有，则某进程对映射内容的修改对于其他进程是不可见的，而且这些改动也不会真地落实到文件上；若传入标志为共享，对映射内容的修改就会为其他进程所见，并且这些修改也会造成对文件的改动。内存映射用途很多，其中包括：以可执行文件的相应段来初始化进程的文本段、内存（内容填充为 0）分配、文件 I/O（即映射内存 I/O）以及进程间通信（通过共享映射）。  



## 进程间通信IPC

方式有：
- 信号（ signal），用来表示事件的发生。
- 管道（亦即 shell 用户所熟悉的“ |”操作符）和 FIFO，用于在进程间传递数据。
- 套接字，供同一台主机或是联网的不同主机上所运行的进程之间传递数据。
- 文件锁定，为防止其他进程读取或更新文件内容，允许某进程对文件的部分区域加以锁定。
- 消息队列，用于在进程间交换消息（数据包）。
- 信号量（ semaphore），用来同步进程动作。
- 共享内存，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容时，其他所有进程会立即了解到这一变化。

贴士：就本质而言， FIFO和 UNIX 套接字功能相同，允许同一系统上并无关联的进程彼此交换数据。二者之所以并存于现代 UNIX 系统之中，是由于 FIFO 来自 System V，而套接字则源于 BSD  

## 线程

每个进程都可执行多个线程。可将线程想象为共享同一虚拟内存及一干其他属性的进程。每个线程都会执行相同的程序代码，共享同一数据区域和堆。可是，
每个线程都拥有属于自己的栈，用来装载本地变量和函数调用链接信息。  

线程之间可通过共享的全局变量进行通信。借助于线程 API 所提供的条件变量和互斥机制，进程所属的线程之间得以相互通信并同步行为—尤其是在对共享变量的使用方面。此外，  利用 IPC 和同步机制，线程间也能彼此通信。  

线程的主要优点在于协同线程之间的数据共享（通过全局变量）更为容易，而且就某些算法而论，以多线程来实现比之以多进程实现要更加自然。再者，显而易见，多线程应用能从多处理器硬件的并行处理中获益匪浅。

## 进程组和 shell 任务控制

shell 执行的每个程序都会在一个新进程内发起。比如， shell 创建了 3 个进程来执行以下管道命令（在当前的工作目录下，根据文件大小对文件进行排序并显示）：

```
$ ls -l | sort -k5n | less
```

在支持任务控制的 shell 中，会将管道内的所有进程置于一个新进程组或任务中。（如果情况很简单， shell 命令行只包含一条命令，那么就会
创建一个只包含单个进程的新进程组。 ）进程组中的每个进程都具有相同的进程组标识符（以整数形式），其实就是进程组中某个进程（也称为进程组组长 process group leader）的进程 ID。  

内核可对进程组中的所有成员执行各种动作，尤其是信号的传递。

## 会话、控制终端和控制进程

会话指的是一组进程组（任务）。会话中的所有进程都具有相同的会话标识符。会话首进程（ session leader）是指创建会话的进程，其进程 ID 会成为会话 ID  

使用会话最多的是支持任务控制的 shell，由 shell 创建的所有进程组与 shell 自身隶属于同一会话， shell 是此会话的会话首进程。  

在任一时点，会话中总有一个前台进程组（前台任务），可以从终端中读取输入，向终端发送输出:  

如果用户在控制终端中输入了“中断”（通常是 Control-C）或“挂起”字符（通常是 Control-Z），那么终端驱动程序会发送信号以终止或挂起（亦即停止）前台进程组。  

一个会话可以拥有任意数量的后台进程组（后台任务），由以“ &”字符结尾的行命令来创建。支持任务控制的 shell 提供如下命令：列出所有任务，向任务发送信号，以及在前后台任务之间来回切换.  

伪终端：伪终端是一对相互连接的虚拟设备，也称为主从设备。在这对设备之间，设有一条 IPC信道，可供数据进行双向传递，比如市面上的ssh软件。  

## 进程与实践

- 真实时间：进程的生命周期时间  
- 进程时间：也称为CPU时间，指进程自启动起来，所占用cpu时间总量
  - 系统CPU时间：内核模式中，执行代码花费的时间，比如执行系统调用
  - 用户CPU时间：用户模式中，执行代码花费的时间，比如常规代码运行

time命令会显示出真实时间、系统CPU时间，以及执行管道中的多个进程花费的用户CPU时间。  


## 实时性

为支持实时性应用， POSIX.1b 定义了多个 POSIX.1 扩展，其中包括异步 I/O、共享内存、内存映射文件、内存锁定、实时性时钟和定时器、备选调度策略、实时性信号、消息队列、以及信号量等

## /proc文件系统

/proc 文件系统装配与 /proc 目录下。  

/proc 文件系统是一种虚拟文件系统，以文件系统目录和文件形式，提供一个指向内核数据结构的接口。  

这为查看和改变各种系统属性开启了方便之门。此外，还能通过一组以/proc/PID 形式命名的目录（ PID 即进程 ID）查看系统中运行各进程的相关信息。
通常， /proc 目录下的文件内容都采取人类可读的文本形式， shell 脚本也能对其进行解析。  

程序可以打开、读取和写入/proc 目录下的既定文件。大多数情况下，只有特权级进程才能修改/proc 目录下的文件内容。  


## 操作系统模型

系统模型：计算机用操作系统来管理所有的资源，并将不同的设备和不同的程序连接起来。有了操作系统后，多用户的连接，各种数据读写操作才能得到有效的控制和管理。  

贴士：操作系统 也是程序，与普通程序一样，运行在内存中，同时它也是一个特殊的程序，能够把普通程序与其他程序、设备连接起来。

有了系统模型，计算机的内存空间就会被划分为两部分：
- 用户空间：容纳应用程序的内存空间，所有的程序都必须在内存空间中才能运行
- 系统空间：容纳操作系统的内存空间，也可以称为内核

必须通过内核，程序要访问设备（键盘、磁盘等），因为只有内核才能直接管理设备。

## 系统资源

内核用来管理资源，那么操作系统有哪些资源：
- 1.处理器（Processor）：执行指令（程序）的硬件设备，有1到多个，内核可以安排一个程序何时执行，何时暂停，何时恢复，何时终止
- 2.输入输出（I/O):终端、程序、硬盘等地方的输入/输出数据都会经过内核，这样的好处是：
  - 数据流不会流错地方
  - 开发者不需要考虑不同的设备差异
  - 数据信息不会被未授权的程序非法访问
- 3.进程管理（Process Management）：进程代表一个程序的运行，进程内包含了该程序的资源：内存、打开的文件、运行时所需系统资源，内核可以新建进程、终止进程、调度进程
- 4.内存（Memory）：只有加载到内存的程序才可以运行。内核在需要的时候回给程序分配内存、回收内存，并能保证内存不被其他进程非法访问
- 5.设备（Device）：内核能够屏蔽光驱、鼠标、扫描仪等外设的差异，如：一个程序想要从计算机中拷贝照片到移动硬盘中，只需要向内核提出操作该资源的请求即可
- 6.计时器（Timers）：程序的工作与实践有关，有时需要定时被处罚，有时需要等待，有时需要知道运行消耗实践，内核可以通过系统调用向程序提供计时器服务
- 7.进程间通信（Interprocess Communication）：各个进程之间需要通信，内核为通信提供一系列方式
- 8.网络（Networking）：不同主机的进程，即使使用不同的操作系统也可以互相通信，内核会提供通信的标准服务

Unix系统编程中重要的三个方面：
- 通信：某个用户或者进程如何与其他用户或进程交换信息
- 协作：程序如何协调多个进程使他们能够没有冲突的访问共享资源
- 网络：不同计算机之间通过网络连接到一起，计算机中的程序如何使用网络访问其他计算机的资源


## 信号

Ctrl+C可以终止一个正在运行的程序，这个中断是由一个内核机制产生，该机制即信号。  

Ctrl+C产生的信号工作机制：
- 1 驱动程序收到Ctrl+C产生的字符（可以是Ctrl-C，也可以是stty，tcsetattr）
- 2 匹配VINTR和ISIG的字符被开启
- 3 驱动程序调用信号系统
- 4 信号系统发送SIGINT到进程
- 5 进程收到SIGINT
- 6 进程消亡

信号：由单个词组成的消息，比如中断信号通常是编码2。  

信号来自内核，但是信号的请求来自三个地方：
- 用户：比如Ctrl-C，或者一些终端驱动产生
- 内核：进程执行出错，内核会向进程发送信号，如浮点数溢出等
- 进程：进程可以通过kill给另一个进程发送信号（其实信号是进程间通信的方式之一）

信号的分类：
- 同步信号（synchronous signals）：由进程的某个操作产生的信号，如：被零除
- 异步信号（asynchronous signals）：由进程外的事件引起的信号，如：用户输入Ctrl-C

liunx中，信号的定义位于`/usr/inlude/signal.h`文件中，如下所示：
```
# define SIGHUP     1
# define SIGINT     2
# define SIGQUIT    3
...
```
SIGINT即是中断信号

## 信号处理模型：进程如何处理信号

比如进程接收到信号SIGINT（终止信号），并不是一定会消亡，进程能够通过系统调用signal告诉内核，该如何处理信号，进程有三种选择：
- 选择1：默认选择（通常会消亡），调用函数为：`signal(SIGINT, SIG_DFL)`
- 选择2：忽略信号，程序调用方法`signal(SIGINT, SIG_IGN)`告诉内核忽略掉SIGINT信号
- 选择3：调用一个函数，该函数被称为信号处理函数，`signal(signum, functionname)`

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

int main() {

    void handler(int);          // 声明信号处理函数
    signal(SIGINT, handler);    // 装载信号处理函数

    int i;
    for(i = 0; i < 100; i++) {
        printf("i==%d\n", i);
        sleep(1);
    }
}

void handler(int signum) {
    printf("handle.... \n");
}
```

上述函数在运行时，使用Ctrl-C发送信号后，程序将会打印：`handle.....`，示例中并没有对handler函数进行显示调用。 

同理，如果signal函数这样书写，则Ctrl-C对程序不会产生影响：
```c
signal(SIGINT, SIG_IGN);
```

## 多信号处理模型

如果只有一个信号要处理，上述原始的信号处理模型足以应付。如果有多个信号到达呢？信号的响应如果是终止或者忽略，则结果很清晰，但是响应式调用一个函数，那么结果会产生影响：

问题一 捕鼠器问题：老鼠被捕获后，捕鼠器就失效了，信号处理函数也是，所以每次捕获信号后，都要重新设置。  
```c
// 为解决捕鼠器问题，信号处理函数可能如下：
void handler(int s) {
    signal(SIGINT, handler);        // 重设处理函数，造成信号捕获后，要先重设处理函数，再执行业务逻辑
    ...                             // 业务处理逻辑    
}

```

就算信号重设的再快，也是耗时的，这时候有可能出现：弹簧被处罚和设置完成之间，老鼠溜走了。这个间隙让信号处理不可靠，称为：不可靠信号。  

问题二：进程在处理一个信号时候，其他到达信号就会阻塞，如果多个信号同时到达，该如何处理：  

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>

int main(int ac, char *av[]) {

    void intHandler(int);
    void quitHandler(int);

    char input[100];
    int nchars;

    signal(SIGINT, intHandler);
    signal(SIGQUIT, quitHandler);

    do {
        printf("\nType a msg\n");
        nchars = read(0, input, 100 - 1);
        if(nchars == -1) {
            perror("read returned an error");
        } else {
            input[nchars] = '\0';
            printf("You typed: %s", input);
        }
    } while( strncmp(input, "quit", 4) != 0);
   
}

void intHandler(int s) {
    printf("Received signal %d .. waiting\n", s);
    sleep(2);
    printf(" Leaving intHandler \n");
}

void quitHandler(int s) {
    printf("Received signal %d .. waiting\n", s);
    sleep(3);
    printf(" Leaving quitHandler \n");
}
```

这时，可以如下操作：
- 同时发出多次 Ctrl-C：会阻塞后续的相同信号
- 发出Ctrl-C后，瞬间发出Ctrl-\：程序会先进入intHandler，再进入quitHandler，再回到intHandler，最后回到主循环。
- 输入文字后，再按Ctrl-C，在输入文字：程序在执行时，收到中断信号，Unix经典模式中是返回并设置EINTR为-1

旧时代信号系统仍然被支持，但是也有新的信号系统，比如POSIX模型中的signaction替代了signal：
```c
signaction(signalnumber, signalaction, prevaction);       # 新操作设置成功返回0，否则返回-1
```
参数一：指定要处理的消息  
参数二：指向如何响应信号的结构体  
参数三：如果不是null，则指向被替换的处理设置的结构体

示例：
```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>

int main(int ac, char *av[]) {

    struct sigaction newHandler;
    sigset_t        blocked;
    void            intHandler();
    char            x[100];

    newHandler.sa_handler = intHandler;
    newHandler.sa_flags = SA_RESETHAND;

    sigemptyset(&blocked);
    sigaddset(&blocked, SIGQUIT);
    newHandler.sa_mask = blocked;

    if(sigaction(SIGINT, &newHandler, NULL) == -1){
        perror("sigaction");
    } else {
        while(1){
            fgets(x, 100, stdin);
            printf("input: %s", x);
        }
    }
   
}

void intHandler(int s) {
    printf("Called with signal %d \n", s);
    sleep(s);
    printf("Done handing signal %d\n", s);
}
```

如果以很快的速度连续按Ctrl-C和Ctrl-\，退出信号将被阻塞直到中断信号处理完毕。  
如果连续按两下Ctrl-C，进程就被第二个信号杀死。  
如果想要捕获所有的Ctrl-C，将SA-RESETHAND掩码从sa_flags中去掉。  

## 临界区

如果某段代码在修改数据时被打断，就会造成数据的不完整，则称这段代码临界区。  

程序在处理信号时，必须决定哪一段代码是临界区，然后设法保护这段代码。但是很多临界区不一定就在信号处理函数中，而是在常规程序流中，保护临界区的简单办法是阻塞或忽略那些处理函数将要使用或者修改特定数据的信号。  

可以在信号处理者一级或者进程一级阻塞信号。  

#### 在信号处理者一级阻塞信号

为了在处理一个信号的时候阻塞另一个信号，要设置struct sigaction结构中的sa_mask成员位，它在设置处理函数时被传递给sigaction。 sa_mask是sigset_t类型，定义了一个信号集。

#### 进程的信号阻塞

进程一直都有一些信号被阻塞，这些信号集称为信号挡板（signal mask），通过sigprocmask可以修改这个被阻塞的信号集，sigprocmask本身也是一个原子操作：
```c
int res = sigprocmask(int how, const sigset_t * sigs, sigset_t * prev);     // 返回值为0则成功，-1为失败
```
参数：
- how：如何修改信号挡板
- sigs：指向使用的信号列表的指针
- prev：指向之前的信号挡板列表的指针或者为null

当how值分别为SIG_BLOCK,SIG_UNBLOCK,SIG_SET时候，* sigs所指定的信号将被添加、删除、替换。如果 prev不是null，那么之前的信号挡板设置将被赋值到*prev中。  

#### sigsetops构建信号机

一个sigset_t是一个抽象的信号集，可以通过一些函数来添加或删除信号，基本函数如下：
```c
sigemptyset(sigset_t * setp);           // 清除由setp指向的列表中的所有信号
sigfillset(sigset_t * setp);            // 添加所有的信号到setp指向的类表
sigaddset(sigset_t *setp, int signum);  // 添加signum到setp指向的列表
sigdelset(sigset_t *setp, int signum);  // 从setp指向的列表中删除signum所标识的信号
```

## kill 从另一个进程发送信号

进程可以通过kill系统调用向另一个进程发送信号：
```c
int kill(pid_t pid, int sig);
```
## 未定义信号

Unix有两个信号SIGUSR1和SIGUSR2，没有预定义任务，可以被用户程序使用。  

## 程序的运行

一个程序是存储在文件中的机器指令序列，由编译器将源码编译成二进制文件后，可以运行。运行该程序意味着将这个机器指令序列载入内存然后让处理器逐条执行。  

在Unix中，一个可执行程序是一个机器指令及其数据序列，一个进程是程序运行时的内存空间和设置。  

进程位于用户空间，通过ps(process status)命令查看，每个进程都有一个可以唯一标识的数字，称为PID（进程ID）。
```
ps      #  列出进程
ps -a   #  列出所有进程，包括其他终端、其他用户运行的程序，但并不包括shell进程，-l可以打印更多细节
```

S：代表进程状态，值为R表示进程正在运行，S表示处于睡眠状态
UID：表示该进程所对应的用户
PRI和NI：分别是进程的由县级和niceness级，内核根据这些值来决定什么时候运行进程，一个进程可以增加niceness级别，（类似排队时被安排到更前位置）。
SZ：进程占据内存的大小。
WCHAN：进程睡眠原因，其值read_c或do_sel代表内核地址   


内存可以看做是一个容纳内核和进程的空间，很多系统把内存看做由页面构成的数组，将继承分割到不同的页面，物理上，这些页面存储在固体的芯片中。  
内存实际上是一个字节序列，或者说是一个很大的数组，如果机器有64M内存，那么这个数组大约有6700万个内存位置，其中一些用来存放组成内核的机器指令和数据。   

建立一个进程类似于建立一个磁盘文件，内核要找到一些用来存放程序指令和数据的空闲页，还要额外建立数据结构来存储响应的内存分配情况、进程属性等。  

一个程序运行另外一个程序调用：execvp
建立新的进程：fork



