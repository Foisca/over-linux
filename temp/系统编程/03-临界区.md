## 临界区

如果某段代码在修改数据时被打断，就会造成数据的不完整，则称这段代码临界区。  

程序在处理信号时，必须决定哪一段代码是临界区，然后设法保护这段代码。但是很多临界区不一定就在信号处理函数中，而是在常规程序流中，保护临界区的简单办法是阻塞或忽略那些处理函数将要使用或者修改特定数据的信号。  

可以在信号处理者一级或者进程一级阻塞信号。  

#### 在信号处理者一级阻塞信号

为了在处理一个信号的时候阻塞另一个信号，要设置struct sigaction结构中的sa_mask成员位，它在设置处理函数时被传递给sigaction。 sa_mask是sigset_t类型，定义了一个信号集。

#### 进程的信号阻塞

进程一直都有一些信号被阻塞，这些信号集称为信号挡板（signal mask），通过sigprocmask可以修改这个被阻塞的信号集，sigprocmask本身也是一个原子操作：
```c
int res = sigprocmask(int how, const sigset_t * sigs, sigset_t * prev);     // 返回值为0则成功，-1为失败
```
参数：
- how：如何修改信号挡板
- sigs：指向使用的信号列表的指针
- prev：指向之前的信号挡板列表的指针或者为null

当how值分别为SIG_BLOCK,SIG_UNBLOCK,SIG_SET时候，* sigs所指定的信号将被添加、删除、替换。如果 prev不是null，那么之前的信号挡板设置将被赋值到*prev中。  

#### sigsetops构建信号机

一个sigset_t是一个抽象的信号集，可以通过一些函数来添加或删除信号，基本函数如下：
```c
sigemptyset(sigset_t * setp);           // 清除由setp指向的列表中的所有信号
sigfillset(sigset_t * setp);            // 添加所有的信号到setp指向的类表
sigaddset(sigset_t *setp, int signum);  // 添加signum到setp指向的列表
sigdelset(sigset_t *setp, int signum);  // 从setp指向的列表中删除signum所标识的信号
```

## kill 从另一个进程发送信号

进程可以通过kill系统调用向另一个进程发送信号：
```c
int kill(pid_t pid, int sig);
```
## 未定义信号

Unix有两个信号SIGUSR1和SIGUSR2，没有预定义任务，可以被用户程序使用。  

