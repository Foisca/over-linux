## 信号

Ctrl+C可以终止一个正在运行的程序，这个中断是由一个内核机制产生，该机制即信号。  

Ctrl+C产生的信号工作机制：
- 1 驱动程序收到Ctrl+C产生的字符（可以是Ctrl-C，也可以是stty，tcsetattr）
- 2 匹配VINTR和ISIG的字符被开启
- 3 驱动程序调用信号系统
- 4 信号系统发送SIGINT到进程
- 5 进程收到SIGINT
- 6 进程消亡

信号：由单个词组成的消息，比如中断信号通常是编码2。  

信号来自内核，但是信号的请求来自三个地方：
- 用户：比如Ctrl-C，或者一些终端驱动产生
- 内核：进程执行出错，内核会向进程发送信号，如浮点数溢出等
- 进程：进程可以通过kill给另一个进程发送信号（其实信号是进程间通信的方式之一）

信号的分类：
- 同步信号（synchronous signals）：由进程的某个操作产生的信号，如：被零除
- 异步信号（asynchronous signals）：由进程外的事件引起的信号，如：用户输入Ctrl-C

liunx中，信号的定义位于`/usr/inlude/signal.h`文件中，如下所示：
```
# define SIGHUP     1
# define SIGINT     2
# define SIGQUIT    3
...
```
SIGINT即是中断信号

## 信号处理模型：进程如何处理信号

比如进程接收到信号SIGINT（终止信号），并不是一定会消亡，进程能够通过系统调用signal告诉内核，该如何处理信号，进程有三种选择：
- 选择1：默认选择（通常会消亡），调用函数为：`signal(SIGINT, SIG_DFL)`
- 选择2：忽略信号，程序调用方法`signal(SIGINT, SIG_IGN)`告诉内核忽略掉SIGINT信号
- 选择3：调用一个函数，该函数被称为信号处理函数，`signal(signum, functionname)`

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

int main() {

    void handler(int);          // 声明信号处理函数
    signal(SIGINT, handler);    // 装载信号处理函数

    int i;
    for(i = 0; i < 100; i++) {
        printf("i==%d\n", i);
        sleep(1);
    }
}

void handler(int signum) {
    printf("handle.... \n");
}
```

上述函数在运行时，使用Ctrl-C发送信号后，程序将会打印：`handle.....`，示例中并没有对handler函数进行显示调用。 

同理，如果signal函数这样书写，则Ctrl-C对程序不会产生影响：
```c
signal(SIGINT, SIG_IGN);
```

## 多信号处理模型

如果只有一个信号要处理，上述原始的信号处理模型足以应付。如果有多个信号到达呢？信号的响应如果是终止或者忽略，则结果很清晰，但是响应式调用一个函数，那么结果会产生影响：

问题一 捕鼠器问题：老鼠被捕获后，捕鼠器就失效了，信号处理函数也是，所以每次捕获信号后，都要重新设置。  
```c
// 为解决捕鼠器问题，信号处理函数可能如下：
void handler(int s) {
    signal(SIGINT, handler);        // 重设处理函数，造成信号捕获后，要先重设处理函数，再执行业务逻辑
    ...                             // 业务处理逻辑    
}

```

就算信号重设的再快，也是耗时的，这时候有可能出现：弹簧被处罚和设置完成之间，老鼠溜走了。这个间隙让信号处理不可靠，称为：不可靠信号。  

问题二：进程在处理一个信号时候，其他到达信号就会阻塞，如果多个信号同时到达，该如何处理：  

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>

int main(int ac, char *av[]) {

    void intHandler(int);
    void quitHandler(int);

    char input[100];
    int nchars;

    signal(SIGINT, intHandler);
    signal(SIGQUIT, quitHandler);

    do {
        printf("\nType a msg\n");
        nchars = read(0, input, 100 - 1);
        if(nchars == -1) {
            perror("read returned an error");
        } else {
            input[nchars] = '\0';
            printf("You typed: %s", input);
        }
    } while( strncmp(input, "quit", 4) != 0);
   
}

void intHandler(int s) {
    printf("Received signal %d .. waiting\n", s);
    sleep(2);
    printf(" Leaving intHandler \n");
}

void quitHandler(int s) {
    printf("Received signal %d .. waiting\n", s);
    sleep(3);
    printf(" Leaving quitHandler \n");
}
```

这时，可以如下操作：
- 同时发出多次 Ctrl-C：会阻塞后续的相同信号
- 发出Ctrl-C后，瞬间发出Ctrl-\：程序会先进入intHandler，再进入quitHandler，再回到intHandler，最后回到主循环。
- 输入文字后，再按Ctrl-C，在输入文字：程序在执行时，收到中断信号，Unix经典模式中是返回并设置EINTR为-1

旧时代信号系统仍然被支持，但是也有新的信号系统，比如POSIX模型中的signaction替代了signal：
```c
signaction(signalnumber, signalaction, prevaction);       # 新操作设置成功返回0，否则返回-1
```
参数一：指定要处理的消息  
参数二：指向如何响应信号的结构体  
参数三：如果不是null，则指向被替换的处理设置的结构体

示例：
```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>

int main(int ac, char *av[]) {

    struct sigaction newHandler;
    sigset_t        blocked;
    void            intHandler();
    char            x[100];

    newHandler.sa_handler = intHandler;
    newHandler.sa_flags = SA_RESETHAND;

    sigemptyset(&blocked);
    sigaddset(&blocked, SIGQUIT);
    newHandler.sa_mask = blocked;

    if(sigaction(SIGINT, &newHandler, NULL) == -1){
        perror("sigaction");
    } else {
        while(1){
            fgets(x, 100, stdin);
            printf("input: %s", x);
        }
    }
   
}

void intHandler(int s) {
    printf("Called with signal %d \n", s);
    sleep(s);
    printf("Done handing signal %d\n", s);
}
```

如果以很快的速度连续按Ctrl-C和Ctrl-\，退出信号将被阻塞直到中断信号处理完毕。  
如果连续按两下Ctrl-C，进程就被第二个信号杀死。  
如果想要捕获所有的Ctrl-C，将SA-RESETHAND掩码从sa_flags中去掉。  

