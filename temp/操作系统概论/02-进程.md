## 进程

进程是正在执行的程序实例。执行程序时，内核会将程序代码载入虚拟内存，为程序变量分配空间，建立内核记账（ bookkeeping）数据结构，以记录与进程有关的各种信息（比如，进程 ID、用户 ID、组 ID 以及终止状态等）。  

在内核看来，进程是一个个实体，内核必须在它们之间共享各种计算机资源。内核一开始会为进程分配一定数量的资源（如受限的内存），并在进程的生命周期内，
统筹该进程和整个系统对资源的需求，对这一分配进行调整。程序终止时，内核会释放所有此类资源，供其他进程重新使用。其他资源（如 CPU、网络带宽等）都属于可再生资源，但必须在所有进程间平等共享。  


逻辑上将一个进程划分为以下几部分（即在内存找那个的布局）：
- 文本：程序的指令。
- 数据：程序使用的静态变量。
- 堆：程序可从该区域动态分配额外内存。
- 栈：随函数调用、返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间。  

#### 创建进程

进程可使用系统调用 fork()来创建一个新进程。调用 fork()的进程被称为父进程，新创建的进程则被称为子进程。  

内核通过对父进程的复制来创建子进程。子进程从父进程处继承数据段、栈段以及堆段的副本后，可以修改这些内容，不会影响父进程的“原版”内容。 （在内存中被标记为只读的程序文本段则由父、子进程共享。 ）  

#### 进程执行程序

子进程被创建后：
- 要么去执行与父进程共享代码段中的另一组不同函数
- 要么使用系统调用 execve()去加载并执行一个全新程序。 execve()会销毁现有的文本段、数据段、栈段及堆段，并根据新程序的代码，创建新段来替换它们。  

贴士：实际上不存在exec()库函数，而是以此名称为基础，C语言提供了多个相关函数。   

#### 进程ID和父进程ID 

每一进程都有一个唯一的整数型进程标识符（ PID）。此外，每一进程还具有一个父进程标识符（ PPID）属性，用以标识请求内核创建自己的进程。  

#### 进程终止和终止状态

可使用以下两种方式之一来终止一个进程：
- 方式一：进程可使用_exit()系统调用（或相关的exit()库函数），请求退出，此时进程会指明自己的终止状态
- 方式二：向进程传递信号，将其“杀死”，此时根据信号类型设置进程终止状态

贴士：
- 退出的进程都会生成“终止状态”，一个非负小整数，可供父进程的wait()系统调用检测。  
- 有时会将传递进_exit()的参数称为进程的“退出状态”，以示与终止状态有所不同，后者要么指传递给_exit()的参数值，要么表示“杀死”进程的信号。

根据惯例，终止状态为 0 表示进程“功成身退”，非 0 则表示有错误发生。大多数 shell 会将前一执行程序的终止状态保存于 shell 变量$?中。  

#### 进程的用户和组标识符（凭证）

每个进程都有一组与之相关的用户 ID (UID)和组 ID (GID)，如下所示：
- 真实用户 ID 和组 ID：用来标识进程所属的用户和组。新进程从其父进程处继承这些 ID。登录 shell 则会从系统密码文件的相应字段中获取其真实用户 ID 和组 ID。
- 有效用户 ID 和组 ID：进程在访问受保护资源（比如，文件和进程间通信对象）时，会使用这两个 ID（并结合下述的补充组 ID）来确定访问权限。一般情况下，
进程的有效 ID 与相应的真实 ID 值相同。正如即将讨论的那样，改变进程的有效ID 实为一种机制，可使进程具有其他用户或组的权限。
- 补充组 ID：用来标识进程所属的额外组。新进程从其父进程处继承补充组 ID。登录shell 则从系统组文件中获取其补充组 ID。

#### 特权进程

特权进程是指有效用户 ID 为 0（超级用户）的进程。通常由内核所施加的权限限制对此类进程无效。   

“无特权”（或非特权）进程是指由其他用户运行的进程。此类进程的有效用户 ID 为非 0 值，且必须遵守由内核所强加的权限规则。  

由特权进程创建的进程，也可以是特权进程。例如，一个由 root（超级用户）发起的登录 shell。成为特权进程的另一方法是利用 set-user-ID 机制，该机制允许某进程的有效用户ID 等同于该进程所执行程序文件的用户 ID。  

#### 能力（Capabilities）

Linux 把传统上赋予超级用户的权限划分为一组相互独立的单元（称之为“能力”）。  

每次特权操作都与特定的能力相关，仅当进程具有特定能力时，才能执行相应操作。传统意义上的超级用户进程（有效用户 ID 为 0）则相应开启了所有能力。
赋予某进程部分能力，使得其既能够执行某些特权级操作，又防止其执行其他特权级操作。能力的命名以 CAP_为前缀，例如， CAP_KILL。

#### init进程

系统引导时，内核会创建一个名为 init 的特殊进程，即“所有进程之父”，该进程的相应程序文件为/sbin/init。系统的所有进程不是由 init（使用 frok()）“亲自”创建，就是由其后代进程创建。 init 进程的进程号总为 1，且总是以超级用户权限运行。谁（哪怕是超级用户）都不能“杀死” init 进程，只有关闭系统才能终止该进程。 init 的主要任务是创建并监控系统运行所需的一系列进程。   

#### 守护进程


守护进程指的是具有特殊用途的进程，系统创建和处理此类进程的方式与其他进程相同，但以下特征是其所独有的：
- “长生不老”。守护进程通常在系统引导时启动，直至系统关闭前，会一直“健在”。
- 守护进程在后台运行，且无控制终端供其读取或写入数据。

守护进程中的例子有 syslogd（在系统日志中记录消息）和 httpd（利用 HTTP 分发 Web 页面）

#### 环境列表

每个进程都有一份环境列表，即在进程用户空间内存中维护的一组环境变量。这份列表的每一元素都由一个名称及其相关值组成。由 fork()创建的新进程，会继承父进程的环境副本。这也为父子进程间通信提供了一种机制。当进程调用 exec()替换当前正在运行的程序时，新程序要么继承老程序的环境，要么在 exec()调用的参数中指定新环境并加以接收。  

在绝大多数 shell 中，可使用 export 命令来创建环境变量（C shell 使用 setenv 命令），如下所示：
```
$ export MYVAR='hello world'
```

#### 资源限制

每个进程都会消耗诸如打开文件、内存以及 CPU 时间之类的资源。使用系统调用 setrlimit()，进程可为自己消耗的各类资源设定一个上限。此类资源限制的每一项均有两个相关值：软限制（soft limit）限制了进程可以消耗的资源总量，硬限制（ hard limit）软限制的调整上限。非特权进程在针对特定资源调整软限制值时，可将其设置为 0 到相应硬限制值之间的任意值，但硬限制值则只能调低，不能调高。  

由 fork()创建的新进程，会继承其父进程对资源限制的设置。  

使用 ulimit 命令（在 C shell 中为 limit）可调整 shell 的资源限制。 shell 为执行命令所创建的子进程会继承上述资源设置。