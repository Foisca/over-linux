## 内核简介

操作系统往往有两种含义：
- 指完整的软件包，这包括用来管理计算机资源的核心层软件，以及附带的所有标准软件工具，诸如命令行解释器、图形用户界面、文件操作工具和文本编辑器等
- 在更狭义的范围内，是指管理和分配计算机资源（即 CPU、 RAM 和设备）的核心层软件，该含义我们通常称为内核。  

在没有内核的情况下，计算机也能运行程序，但有了内核会极大简化其他程序的编写和使用，因为内核为管理计算机的有限资源提供了软件层。  

内核名称：
- 早期UNIX实现称内核为UNIX
- 实现了虚拟内存机制的 UNIX 系统中，其内核名称变更为 vmunix
- Linux 内核可执行文件采用/boot/vmlinuz 或与之类似的路径名


##  内核职责

####  进程管创建、删除、调度

内核可将新程序载入内存，为其提供运行所需的资源（比如， CPU、内存以及对文件的访问等）。这样一个运行中的程序我们称之为“进程”。一旦进程执行完毕，内核还要确保释放其占用资源，以供后续程序重新使用。  

计算机内均配备有一个或多个 CPU（中央处理单元），以执行程序指令。与其他 UNIX 系统一样， Linux 属于抢占式多任务操作系统。 “多任务”意指多个进程（即运行中的程序）可同时驻留于内存，且每个进程都能获得对 CPU 的使用权。“抢占”则是指一组规则。这组规则控制着哪些进程获得对 CPU 的使用，以及每个进程能使用多长时间，这两者都由内核进程调度程序（而非进程本身）决定。  



#### 内存管理

物理内存（ RAM）属于有限资源，内核必须以公平、高效地方式在进程间共享这一资源。  

与大多数现代操作系统一样， Linux也采用了虚拟内存管理机制，其优势有：
- 进程与进程之间、进程与内核之间彼此隔离，因此一个进程无法读取或修改内核或其他进程的内存内容
- 只需将进程的一部分保持在内存中，这不但降低了每个进程对内存的需求量，而且还能在 RAM 中同时加载更多的进程。这也大幅提升了如下事件的发生概率，在任一时刻， CPU 都有至少一个进程可以执行，从而使得对 CPU 资源的利用更加充分

#### 文件系统

内核在磁盘之上提供有文件系统，允许对文件执行创建、获取、更新以及删除等操作

#### 支持外部设备访问

计算机外接设备（鼠标、键盘、磁盘和磁带驱动器等）可实现计算机与外部世界的通信，这一通信机制包括输入、输出或是两者兼而有之。内核既为程序访问设备提供了简化版的标准接口，同时还要仲裁多个进程对每一个设备的访问。

#### 网络支持

内核以用户进程的名义收发网络消息（数据包）。该任务包括将网络数据包路由至目标系统。

#### 提供系统调用应用编程接口（ API）

进程可利用内核入口点（也称为系统调用）请求内核去执行各种任务。

#### 虚拟私有计算机（ virtual private computer）

Linux 之类的多用户操作系统会为每个用户营造一种抽象：虚拟私有计算机（ virtual private computer）。这就是说，每个用户都可以登录进入系统，独立操作，而与其他用户大致无干。例如，每个用户都有属于自己的磁盘存储空间（主目录）。再者，用户能够运行程序，而每一程序都能从 CPU 资源中“分得一杯羹”，运转于自有的虚拟地址空间中。而且这些程序还能独立访问设备，并通过网络传递信息。内核负责解决（多进程）访问硬件资源时可能引发的冲突，用户和进程对此则往往一无所知。  

## 内核态和用户态

现代处理器架构一般允许 CPU 至少在两种不同状态下运行，即：用户态和核心态（有时也称之为监管态 supervisor mode）。  

执行硬件指令可使 CPU 在两种状态间来回切换。与之对应，可将虚拟内存区域划分（标记）为用户空间部分或内核空间部分。在用户态下运行时， CPU 只能访问被标记为用户空间的内存，试图访问属于内核空间的内存会引发硬件异常。当运行于核心态时， CPU 既能访问用户空间内存，也能访问内核空间内存。  

仅当处理器在核心态运行时，才能执行某些特定操作。这样的例子包括：执行宕机（halt）指令去关闭系统，访问内存管理硬件，以及设备 I/O 操作的初始化等。实现者们利用这一硬件设计，将操作系统置于内核空间。这确保了用户进程既不能访问内核指令和数据结构，也无法执行不利于系统运行的操作。  


一个运行系统通常会有多个进程并行其中。对进程来说，许多事件的发生都无法预期。执行中的进程不清楚自己对 CPU 的占用何时“到期”，系统随之又会调度哪个进程来使用CPU（以及以何种顺序来调度），也不知道自己何时会再次获得对 CPU 的使用。信号的传递和进程间通信事件的触发由内核统一协调，对进程而言，随时可能发生。诸如此类，进程都
一无所知。进程不清楚自己在 RAM 中的位置。或者换种更通用的说法， 进程内存空间的某块特定部分如今到底是驻留在内存中还是被保存在交换空间（磁盘空间中的保留区域，作为计算机 RAM 的补充）里，进程本身并不知晓。与之类似，进程也闹不清自己所访问的文件“居于”磁盘驱动器的何处，只是通过名称来引用文件而已。进程的运作方式堪称“与世隔绝” —进程间彼此不能直接通信。进程本身无法创建出新进程，哪怕“自行了断”都不行。最后还有一点，进程也不能与计算机外接的输入输出设备直接通信。

相形之下，内核则是运行系统的中枢所在，对于系统的一切无所不知、无所不能，为系统上所有进程的运行提供便利。由哪个进程来接掌对 CPU 的使用，何时“接任”， “任期”多久，都由内核说了算。在内核维护的数据结构中，包含了与所有正在运行的进程有关的信息。随着进程的创建、状态发生变化或者终结，内核会及时更新这些数据结构。内核所维护的底层数据结构可将程序使用的文件名转换为磁盘的物理位置。此外，每个进程的虚拟内存与计算机物理内存及磁盘交换区之间的映射关系，也在内核维护的数据结构之列。进程间的所有通信都要通过内核提供的通信机制来完成。响应进程发出的请求，内核会创建新的进程，终结现有进程。最后，由内核（特别是设备驱动程序） 来执行与输入/输出设备之间的所有直接通信， 按需与用户进程交互信息。

## shell

shell 是一种具有特殊用途的程序，主要用于读取用户输入的命令，并执行相应的程序以响应命令。有时，人们也称之为命令解释器。  

尽管某些操作系统将命令解释器集成于内核中，而对 UNIX 系统而言， shell 只是一个用户进程。   

常见shell：
- Bourne shell（ sh）： Steve Bourne 编写，历史悠久，是第七版UNIX的标配shell，包含特性有：I/O 重定向、管道、文件名生成（通配符）、变量、环境变量处理、命令替换、后台命令执行以及函数
- C shell（ csh）： Bill Joy 于加州大学伯克利分校编写而成，命名因为与C语法相似。csh与sh不兼容！
- Korn shell（ ksh）： AT&T 贝尔实验室的 David Korn 编写了这款 shell，保持了与 sh 兼容的同时，也吸收了 csh 交互式特性
- Bourne again shell（ bash）：这款 shell 是 GNU 项目对 Bourne shell 的重新实现。提供了与 C shell 和 Korn shel 所类似的交互式特性，Linux的上Bourne shell（ sh）其实正是由 bash 仿真提供的

## 用户和用户组

系统会对每个用户的身份做唯一标识，用户可隶属于多个组  

#### 用户

系统的每个用户都拥有唯一的登录名（用户名）和与之相对应的整数型用户 ID（UID）。系统密码文件/etc/passwd 为每个用户都定义有一行记录，除了上述两项信息外，该记录还包含如下信息：
- 组 ID：用户所属第一个组的整数型组 ID。
- 主目录：用户登录后所居于的初始目录。
- 登录 shell：执行以解释用户命令的程序名称。

该记录还能以加密形式保存用户密码。然而，出于安全考虑，用户密码往往存储于单独的 shadow 密码文件中，仅供特权用户阅读。  


#### 组


出于管理目的，尤其是为了控制对文件和其他资源的访问，将多个用户分组是非常实用的做法。例如，某项目的开发团队人员需要共享同一组文件，就可以将他们编为同一组的成员。在早期的 UNIX 实现中，一个用户只能隶属于一个组。 BSD 率先允许一个用户同时属于多个组，这一理念后来被其他 UNIX 实现纷纷效仿，并最终成为 POSIX.1-1990 标准。每个用户组都对应着系统组文件/etc/group 中的一行记录，该记录包含如下信息。
-  组名： （唯一的）组名称。
-  组 ID（ GID）：与组相关的整数型 ID。
-  用户列表：隶属于该组的用户登录名列表（通过密码文件记录的 group ID 字段未能标识出的该组其他成员，也在此列），以逗号分隔

#### 超级用户

超级用户账号的用户 ID 为 0，通常登录名为 root。超级用户凌驾于系统的权限检查之上。因此，无论对文件施以何种访问权限限制，超级用户都可以访问系统中的任何文件，也能发送信号干预系统运行的所有用户进程。系统管理员可以使用超级用户账号来执行各种系统管理任务。  

## 单根目录层级、目录、链接及文件

内核维护着一套单根目录结构，以放置系统的所有文件。（这与微软 Windows 之类的操作系统形成了鲜明对照， Windows 系统的每个磁盘设备都有各自的目录层级。 ）这一目录层级的根基就是名为“ /”的根目录。  

#### 文件类型

文件系统内，会对文件类型进行标记，以表明其种类。其中一种用来表示普通数据文件，人们常称之为“普通文件”或“纯文本文件”，以示与其他种类的文件有所区别。其他文
件类型包括设备、管道、套接字、目录以及符号链接。  

#### 文件的所有权和权限

每个文件都有一个与之相关的用户 ID 和组 ID，分别定义文件的属主和属组。系统根据文件的所有权来判定用户对文件的访问权限。  

为了访问文件，系统把用户分为 3 类：文件的属主（有时，也称为文件的用户）、与文件组（ group） ID 相匹配的属组成员用户以及其他用户。 可为以上 3 类用户分别设置 3 种权限（共计 9 种权限位）：只允许查看文件内容的读权限；允许修改文件内容的写权限；允许执行文件的执行权限。这里的文件要么指程序，要么是交由某种解释程序（通常指 shell 的一种，但也有例外）处理的脚本。也可针对目录进行上述权限设置，但意义稍有不同。读权限允许列出目录内容（即该目录下的文件名），写权限允许对目录内容进行更改（比如，添加、修改或删除文件名），执行（有时也称为搜索）权限允许对目录中的文件进行访问（但需受文件自身访问权限的约束）。  

## 文件 I/O 模型

UNIX 系统 I/O 模型最为显著的特性之一是其 I/O 通用性概念。也就是说，同一套系统调用（ open()、 read()、 write()、 close()等）所执行的 I/O 操作，可施之于所有文件类型，包括设备文件在内。 （应用程序发起的 I/O 请求，内核会将其转化为相应的文件系统操作，或者设备驱动程序操作，以此来执行针对目标文件或设备的 I/O 操作。 ）因此，采用这些系统调用的程序能够处理任何类型的文件。  

就本质而言，内核只提供一种文件类型：字节流序列，在处理磁盘文件、磁盘或磁带设备时，可通过 lseek()系统调用来随机访问。  

许多应用程序和函数库都将新行符（十进制 ASCII 码为 10，有时亦称其为换行）视为文本中一行的结束和另一行的开始。 UNIX 系统没有文件结束符的概念，读取文件时如无数据返回，便会认定抵达文件末尾。  

#### 文件描述符

I/O 系统调用使用文件描述符—（往往是数值很小的）非负整数—来指代打开的文件。获取文件描述符的常用手法是调用 open()，在参数中指定 I/O 操作目标文件的路径名。  

通常，由 shell 启动的进程会继承 3 个已打开的文件描述符：
- 标准输入：描述符为0，对应stdio函数库中的stdin，指代为进程提供输入的文件
- 标准输出：描述符为1，对应stdio函数库中的stdout，指代供进程写入输出的文件
- 标准错误：描述符为2，对应stdio函数库中的stderr，指代供进程写入错误消息或异常通告的文件





